// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "OpenDRIVE_1.4H.hxx"

// link_t
// 

const link_t::predecessor_type& link_t::
predecessor () const
{
  return this->predecessor_.get ();
}

link_t::predecessor_type& link_t::
predecessor ()
{
  return this->predecessor_.get ();
}

void link_t::
predecessor (const predecessor_type& x)
{
  this->predecessor_.set (x);
}

void link_t::
predecessor (::std::unique_ptr< predecessor_type > x)
{
  this->predecessor_.set (std::move (x));
}

const link_t::successor_type& link_t::
successor () const
{
  return this->successor_.get ();
}

link_t::successor_type& link_t::
successor ()
{
  return this->successor_.get ();
}

void link_t::
successor (const successor_type& x)
{
  this->successor_.set (x);
}

void link_t::
successor (::std::unique_ptr< successor_type > x)
{
  this->successor_.set (std::move (x));
}


// elementType
// 

elementType::
elementType (value v)
: ::xml_schema::string (_xsd_elementType_literals_[v])
{
}

elementType::
elementType (const char* v)
: ::xml_schema::string (v)
{
}

elementType::
elementType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

elementType::
elementType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

elementType::
elementType (const elementType& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

elementType& elementType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_elementType_literals_[v]);

  return *this;
}


// contactPoint
// 

contactPoint::
contactPoint (value v)
: ::xml_schema::string (_xsd_contactPoint_literals_[v])
{
}

contactPoint::
contactPoint (const char* v)
: ::xml_schema::string (v)
{
}

contactPoint::
contactPoint (const ::std::string& v)
: ::xml_schema::string (v)
{
}

contactPoint::
contactPoint (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

contactPoint::
contactPoint (const contactPoint& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

contactPoint& contactPoint::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_contactPoint_literals_[v]);

  return *this;
}


// singleSide
// 

singleSide::
singleSide (value v)
: ::xml_schema::string (_xsd_singleSide_literals_[v])
{
}

singleSide::
singleSide (const char* v)
: ::xml_schema::string (v)
{
}

singleSide::
singleSide (const ::std::string& v)
: ::xml_schema::string (v)
{
}

singleSide::
singleSide (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

singleSide::
singleSide (const singleSide& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

singleSide& singleSide::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_singleSide_literals_[v]);

  return *this;
}


// roadBoundary
// 

const roadBoundary::geometry_type& roadBoundary::
geometry () const
{
  return this->geometry_.get ();
}

roadBoundary::geometry_type& roadBoundary::
geometry ()
{
  return this->geometry_.get ();
}

void roadBoundary::
geometry (const geometry_type& x)
{
  this->geometry_.set (x);
}

void roadBoundary::
geometry (::std::unique_ptr< geometry_type > x)
{
  this->geometry_.set (std::move (x));
}


// geometry
// 

const geometry::point_sequence& geometry::
point () const
{
  return this->point_;
}

geometry::point_sequence& geometry::
point ()
{
  return this->point_;
}

void geometry::
point (const point_sequence& s)
{
  this->point_ = s;
}


// halfRoad
// 

const halfRoad::lane_sequence& halfRoad::
lane () const
{
  return this->lane_;
}

halfRoad::lane_sequence& halfRoad::
lane ()
{
  return this->lane_;
}

void halfRoad::
lane (const lane_sequence& s)
{
  this->lane_ = s;
}


// centerRoad
// 

const centerRoad::lane_type& centerRoad::
lane () const
{
  return this->lane_.get ();
}

centerRoad::lane_type& centerRoad::
lane ()
{
  return this->lane_.get ();
}

void centerRoad::
lane (const lane_type& x)
{
  this->lane_.set (x);
}

void centerRoad::
lane (::std::unique_ptr< lane_type > x)
{
  this->lane_.set (std::move (x));
}


// lane
// 

const lane::link_type& lane::
link () const
{
  return this->link_.get ();
}

lane::link_type& lane::
link ()
{
  return this->link_.get ();
}

void lane::
link (const link_type& x)
{
  this->link_.set (x);
}

void lane::
link (::std::unique_ptr< link_type > x)
{
  this->link_.set (std::move (x));
}

const lane::centerLine_optional& lane::
centerLine () const
{
  return this->centerLine_;
}

lane::centerLine_optional& lane::
centerLine ()
{
  return this->centerLine_;
}

void lane::
centerLine (const centerLine_type& x)
{
  this->centerLine_.set (x);
}

void lane::
centerLine (const centerLine_optional& x)
{
  this->centerLine_ = x;
}

void lane::
centerLine (::std::unique_ptr< centerLine_type > x)
{
  this->centerLine_.set (std::move (x));
}

const lane::leftBorder_optional& lane::
leftBorder () const
{
  return this->leftBorder_;
}

lane::leftBorder_optional& lane::
leftBorder ()
{
  return this->leftBorder_;
}

void lane::
leftBorder (const leftBorder_type& x)
{
  this->leftBorder_.set (x);
}

void lane::
leftBorder (const leftBorder_optional& x)
{
  this->leftBorder_ = x;
}

void lane::
leftBorder (::std::unique_ptr< leftBorder_type > x)
{
  this->leftBorder_.set (std::move (x));
}

const lane::border_type& lane::
border () const
{
  return this->border_.get ();
}

lane::border_type& lane::
border ()
{
  return this->border_.get ();
}

void lane::
border (const border_type& x)
{
  this->border_.set (x);
}

void lane::
border (::std::unique_ptr< border_type > x)
{
  this->border_.set (std::move (x));
}

const lane::speed_optional& lane::
speed () const
{
  return this->speed_;
}

lane::speed_optional& lane::
speed ()
{
  return this->speed_;
}

void lane::
speed (const speed_type& x)
{
  this->speed_.set (x);
}

void lane::
speed (const speed_optional& x)
{
  this->speed_ = x;
}

void lane::
speed (::std::unique_ptr< speed_type > x)
{
  this->speed_.set (std::move (x));
}

const lane::id_optional& lane::
id () const
{
  return this->id_;
}

lane::id_optional& lane::
id ()
{
  return this->id_;
}

void lane::
id (const id_type& x)
{
  this->id_.set (x);
}

void lane::
id (const id_optional& x)
{
  this->id_ = x;
}

const lane::type_optional& lane::
type () const
{
  return this->type_;
}

lane::type_optional& lane::
type ()
{
  return this->type_;
}

void lane::
type (const type_type& x)
{
  this->type_.set (x);
}

void lane::
type (const type_optional& x)
{
  this->type_ = x;
}

void lane::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const lane::turnType_optional& lane::
turnType () const
{
  return this->turnType_;
}

lane::turnType_optional& lane::
turnType ()
{
  return this->turnType_;
}

void lane::
turnType (const turnType_type& x)
{
  this->turnType_.set (x);
}

void lane::
turnType (const turnType_optional& x)
{
  this->turnType_ = x;
}

void lane::
turnType (::std::unique_ptr< turnType_type > x)
{
  this->turnType_.set (std::move (x));
}


// borderType
// 

borderType::
borderType (value v)
: ::xml_schema::string (_xsd_borderType_literals_[v])
{
}

borderType::
borderType (const char* v)
: ::xml_schema::string (v)
{
}

borderType::
borderType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

borderType::
borderType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

borderType::
borderType (const borderType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

borderType& borderType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_borderType_literals_[v]);

  return *this;
}


// laneType
// 

laneType::
laneType (value v)
: ::xml_schema::string (_xsd_laneType_literals_[v])
{
}

laneType::
laneType (const char* v)
: ::xml_schema::string (v)
{
}

laneType::
laneType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

laneType::
laneType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

laneType::
laneType (const laneType& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

laneType& laneType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_laneType_literals_[v]);

  return *this;
}


// objectType
// 

objectType::
objectType (value v)
: ::xml_schema::string (_xsd_objectType_literals_[v])
{
}

objectType::
objectType (const char* v)
: ::xml_schema::string (v)
{
}

objectType::
objectType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

objectType::
objectType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

objectType::
objectType (const objectType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

objectType& objectType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_objectType_literals_[v]);

  return *this;
}


// OpenDRIVE
// 

const OpenDRIVE::header_type& OpenDRIVE::
header () const
{
  return this->header_.get ();
}

OpenDRIVE::header_type& OpenDRIVE::
header ()
{
  return this->header_.get ();
}

void OpenDRIVE::
header (const header_type& x)
{
  this->header_.set (x);
}

void OpenDRIVE::
header (::std::unique_ptr< header_type > x)
{
  this->header_.set (std::move (x));
}

const OpenDRIVE::road_sequence& OpenDRIVE::
road () const
{
  return this->road_;
}

OpenDRIVE::road_sequence& OpenDRIVE::
road ()
{
  return this->road_;
}

void OpenDRIVE::
road (const road_sequence& s)
{
  this->road_ = s;
}

const OpenDRIVE::junction_sequence& OpenDRIVE::
junction () const
{
  return this->junction_;
}

OpenDRIVE::junction_sequence& OpenDRIVE::
junction ()
{
  return this->junction_;
}

void OpenDRIVE::
junction (const junction_sequence& s)
{
  this->junction_ = s;
}


// predecessor
// 

const predecessor::elementId_optional& predecessor::
elementId () const
{
  return this->elementId_;
}

predecessor::elementId_optional& predecessor::
elementId ()
{
  return this->elementId_;
}

void predecessor::
elementId (const elementId_type& x)
{
  this->elementId_.set (x);
}

void predecessor::
elementId (const elementId_optional& x)
{
  this->elementId_ = x;
}

void predecessor::
elementId (::std::unique_ptr< elementId_type > x)
{
  this->elementId_.set (std::move (x));
}

const predecessor::elementType_optional& predecessor::
elementType () const
{
  return this->elementType_;
}

predecessor::elementType_optional& predecessor::
elementType ()
{
  return this->elementType_;
}

void predecessor::
elementType (const elementType_type& x)
{
  this->elementType_.set (x);
}

void predecessor::
elementType (const elementType_optional& x)
{
  this->elementType_ = x;
}

void predecessor::
elementType (::std::unique_ptr< elementType_type > x)
{
  this->elementType_.set (std::move (x));
}

const predecessor::contactPoint_optional& predecessor::
contactPoint () const
{
  return this->contactPoint_;
}

predecessor::contactPoint_optional& predecessor::
contactPoint ()
{
  return this->contactPoint_;
}

void predecessor::
contactPoint (const contactPoint_type& x)
{
  this->contactPoint_.set (x);
}

void predecessor::
contactPoint (const contactPoint_optional& x)
{
  this->contactPoint_ = x;
}

void predecessor::
contactPoint (::std::unique_ptr< contactPoint_type > x)
{
  this->contactPoint_.set (std::move (x));
}

const predecessor::id_optional& predecessor::
id () const
{
  return this->id_;
}

predecessor::id_optional& predecessor::
id ()
{
  return this->id_;
}

void predecessor::
id (const id_type& x)
{
  this->id_.set (x);
}

void predecessor::
id (const id_optional& x)
{
  this->id_ = x;
}


// successor
// 

const successor::elementId_optional& successor::
elementId () const
{
  return this->elementId_;
}

successor::elementId_optional& successor::
elementId ()
{
  return this->elementId_;
}

void successor::
elementId (const elementId_type& x)
{
  this->elementId_.set (x);
}

void successor::
elementId (const elementId_optional& x)
{
  this->elementId_ = x;
}

void successor::
elementId (::std::unique_ptr< elementId_type > x)
{
  this->elementId_.set (std::move (x));
}

const successor::elementType_optional& successor::
elementType () const
{
  return this->elementType_;
}

successor::elementType_optional& successor::
elementType ()
{
  return this->elementType_;
}

void successor::
elementType (const elementType_type& x)
{
  this->elementType_.set (x);
}

void successor::
elementType (const elementType_optional& x)
{
  this->elementType_ = x;
}

void successor::
elementType (::std::unique_ptr< elementType_type > x)
{
  this->elementType_.set (std::move (x));
}

const successor::contactPoint_optional& successor::
contactPoint () const
{
  return this->contactPoint_;
}

successor::contactPoint_optional& successor::
contactPoint ()
{
  return this->contactPoint_;
}

void successor::
contactPoint (const contactPoint_type& x)
{
  this->contactPoint_.set (x);
}

void successor::
contactPoint (const contactPoint_optional& x)
{
  this->contactPoint_ = x;
}

void successor::
contactPoint (::std::unique_ptr< contactPoint_type > x)
{
  this->contactPoint_.set (std::move (x));
}

const successor::id_optional& successor::
id () const
{
  return this->id_;
}

successor::id_optional& successor::
id ()
{
  return this->id_;
}

void successor::
id (const id_type& x)
{
  this->id_.set (x);
}

void successor::
id (const id_optional& x)
{
  this->id_ = x;
}


// point
// 

const point::x_optional& point::
x () const
{
  return this->x_;
}

point::x_optional& point::
x ()
{
  return this->x_;
}

void point::
x (const x_type& x)
{
  this->x_.set (x);
}

void point::
x (const x_optional& x)
{
  this->x_ = x;
}

const point::y_optional& point::
y () const
{
  return this->y_;
}

point::y_optional& point::
y ()
{
  return this->y_;
}

void point::
y (const y_type& x)
{
  this->y_.set (x);
}

void point::
y (const y_optional& x)
{
  this->y_ = x;
}

const point::z_optional& point::
z () const
{
  return this->z_;
}

point::z_optional& point::
z ()
{
  return this->z_;
}

void point::
z (const z_type& x)
{
  this->z_.set (x);
}

void point::
z (const z_optional& x)
{
  this->z_ = x;
}


// centerLine
// 

const centerLine::geometry_optional& centerLine::
geometry () const
{
  return this->geometry_;
}

centerLine::geometry_optional& centerLine::
geometry ()
{
  return this->geometry_;
}

void centerLine::
geometry (const geometry_type& x)
{
  this->geometry_.set (x);
}

void centerLine::
geometry (const geometry_optional& x)
{
  this->geometry_ = x;
}

void centerLine::
geometry (::std::unique_ptr< geometry_type > x)
{
  this->geometry_.set (std::move (x));
}


// leftBorder
// 

const leftBorder::geometry_type& leftBorder::
geometry () const
{
  return this->geometry_.get ();
}

leftBorder::geometry_type& leftBorder::
geometry ()
{
  return this->geometry_.get ();
}

void leftBorder::
geometry (const geometry_type& x)
{
  this->geometry_.set (x);
}

void leftBorder::
geometry (::std::unique_ptr< geometry_type > x)
{
  this->geometry_.set (std::move (x));
}


// border
// 

const border::geometry_type& border::
geometry () const
{
  return this->geometry_.get ();
}

border::geometry_type& border::
geometry ()
{
  return this->geometry_.get ();
}

void border::
geometry (const geometry_type& x)
{
  this->geometry_.set (x);
}

void border::
geometry (::std::unique_ptr< geometry_type > x)
{
  this->geometry_.set (std::move (x));
}

const border::borderInfo_sequence& border::
borderInfo () const
{
  return this->borderInfo_;
}

border::borderInfo_sequence& border::
borderInfo ()
{
  return this->borderInfo_;
}

void border::
borderInfo (const borderInfo_sequence& s)
{
  this->borderInfo_ = s;
}

const border::virtual_optional& border::
virtual_ () const
{
  return this->virtual__;
}

border::virtual_optional& border::
virtual_ ()
{
  return this->virtual__;
}

void border::
virtual_ (const virtual_type& x)
{
  this->virtual__.set (x);
}

void border::
virtual_ (const virtual_optional& x)
{
  this->virtual__ = x;
}

void border::
virtual_ (::std::unique_ptr< virtual_type > x)
{
  this->virtual__.set (std::move (x));
}


// speed
// 

const speed::speedMin_optional& speed::
speedMin () const
{
  return this->speedMin_;
}

speed::speedMin_optional& speed::
speedMin ()
{
  return this->speedMin_;
}

void speed::
speedMin (const speedMin_type& x)
{
  this->speedMin_.set (x);
}

void speed::
speedMin (const speedMin_optional& x)
{
  this->speedMin_ = x;
}

const speed::speedMax_optional& speed::
speedMax () const
{
  return this->speedMax_;
}

speed::speedMax_optional& speed::
speedMax ()
{
  return this->speedMax_;
}

void speed::
speedMax (const speedMax_type& x)
{
  this->speedMax_.set (x);
}

void speed::
speedMax (const speedMax_optional& x)
{
  this->speedMax_ = x;
}


// header
// 

const header::geoReference_optional& header::
geoReference () const
{
  return this->geoReference_;
}

header::geoReference_optional& header::
geoReference ()
{
  return this->geoReference_;
}

void header::
geoReference (const geoReference_type& x)
{
  this->geoReference_.set (x);
}

void header::
geoReference (const geoReference_optional& x)
{
  this->geoReference_ = x;
}

void header::
geoReference (::std::unique_ptr< geoReference_type > x)
{
  this->geoReference_.set (std::move (x));
}

const header::revMajor_optional& header::
revMajor () const
{
  return this->revMajor_;
}

header::revMajor_optional& header::
revMajor ()
{
  return this->revMajor_;
}

void header::
revMajor (const revMajor_type& x)
{
  this->revMajor_.set (x);
}

void header::
revMajor (const revMajor_optional& x)
{
  this->revMajor_ = x;
}

const header::revMinor_optional& header::
revMinor () const
{
  return this->revMinor_;
}

header::revMinor_optional& header::
revMinor ()
{
  return this->revMinor_;
}

void header::
revMinor (const revMinor_type& x)
{
  this->revMinor_.set (x);
}

void header::
revMinor (const revMinor_optional& x)
{
  this->revMinor_ = x;
}

const header::name_optional& header::
name () const
{
  return this->name_;
}

header::name_optional& header::
name ()
{
  return this->name_;
}

void header::
name (const name_type& x)
{
  this->name_.set (x);
}

void header::
name (const name_optional& x)
{
  this->name_ = x;
}

void header::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const header::version_optional& header::
version () const
{
  return this->version_;
}

header::version_optional& header::
version ()
{
  return this->version_;
}

void header::
version (const version_type& x)
{
  this->version_.set (x);
}

void header::
version (const version_optional& x)
{
  this->version_ = x;
}

const header::date_optional& header::
date () const
{
  return this->date_;
}

header::date_optional& header::
date ()
{
  return this->date_;
}

void header::
date (const date_type& x)
{
  this->date_.set (x);
}

void header::
date (const date_optional& x)
{
  this->date_ = x;
}

void header::
date (::std::unique_ptr< date_type > x)
{
  this->date_.set (std::move (x));
}

const header::north_optional& header::
north () const
{
  return this->north_;
}

header::north_optional& header::
north ()
{
  return this->north_;
}

void header::
north (const north_type& x)
{
  this->north_.set (x);
}

void header::
north (const north_optional& x)
{
  this->north_ = x;
}

const header::south_optional& header::
south () const
{
  return this->south_;
}

header::south_optional& header::
south ()
{
  return this->south_;
}

void header::
south (const south_type& x)
{
  this->south_.set (x);
}

void header::
south (const south_optional& x)
{
  this->south_ = x;
}

const header::east_optional& header::
east () const
{
  return this->east_;
}

header::east_optional& header::
east ()
{
  return this->east_;
}

void header::
east (const east_type& x)
{
  this->east_.set (x);
}

void header::
east (const east_optional& x)
{
  this->east_ = x;
}

const header::west_optional& header::
west () const
{
  return this->west_;
}

header::west_optional& header::
west ()
{
  return this->west_;
}

void header::
west (const west_type& x)
{
  this->west_.set (x);
}

void header::
west (const west_optional& x)
{
  this->west_ = x;
}

const header::maxRoad_optional& header::
maxRoad () const
{
  return this->maxRoad_;
}

header::maxRoad_optional& header::
maxRoad ()
{
  return this->maxRoad_;
}

void header::
maxRoad (const maxRoad_type& x)
{
  this->maxRoad_.set (x);
}

void header::
maxRoad (const maxRoad_optional& x)
{
  this->maxRoad_ = x;
}

const header::maxJunc_optional& header::
maxJunc () const
{
  return this->maxJunc_;
}

header::maxJunc_optional& header::
maxJunc ()
{
  return this->maxJunc_;
}

void header::
maxJunc (const maxJunc_type& x)
{
  this->maxJunc_.set (x);
}

void header::
maxJunc (const maxJunc_optional& x)
{
  this->maxJunc_ = x;
}

const header::maxPrg_optional& header::
maxPrg () const
{
  return this->maxPrg_;
}

header::maxPrg_optional& header::
maxPrg ()
{
  return this->maxPrg_;
}

void header::
maxPrg (const maxPrg_type& x)
{
  this->maxPrg_.set (x);
}

void header::
maxPrg (const maxPrg_optional& x)
{
  this->maxPrg_ = x;
}

const header::vendor_optional& header::
vendor () const
{
  return this->vendor_;
}

header::vendor_optional& header::
vendor ()
{
  return this->vendor_;
}

void header::
vendor (const vendor_type& x)
{
  this->vendor_.set (x);
}

void header::
vendor (const vendor_optional& x)
{
  this->vendor_ = x;
}

void header::
vendor (::std::unique_ptr< vendor_type > x)
{
  this->vendor_.set (std::move (x));
}


// road
// 

const road::link_type& road::
link () const
{
  return this->link_.get ();
}

road::link_type& road::
link ()
{
  return this->link_.get ();
}

void road::
link (const link_type& x)
{
  this->link_.set (x);
}

void road::
link (::std::unique_ptr< link_type > x)
{
  this->link_.set (std::move (x));
}

const road::lanes_type& road::
lanes () const
{
  return this->lanes_.get ();
}

road::lanes_type& road::
lanes ()
{
  return this->lanes_.get ();
}

void road::
lanes (const lanes_type& x)
{
  this->lanes_.set (x);
}

void road::
lanes (::std::unique_ptr< lanes_type > x)
{
  this->lanes_.set (std::move (x));
}

const road::objects_type& road::
objects () const
{
  return this->objects_.get ();
}

road::objects_type& road::
objects ()
{
  return this->objects_.get ();
}

void road::
objects (const objects_type& x)
{
  this->objects_.set (x);
}

void road::
objects (::std::unique_ptr< objects_type > x)
{
  this->objects_.set (std::move (x));
}

const road::name_optional& road::
name () const
{
  return this->name_;
}

road::name_optional& road::
name ()
{
  return this->name_;
}

void road::
name (const name_type& x)
{
  this->name_.set (x);
}

void road::
name (const name_optional& x)
{
  this->name_ = x;
}

void road::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const road::length_optional& road::
length () const
{
  return this->length_;
}

road::length_optional& road::
length ()
{
  return this->length_;
}

void road::
length (const length_type& x)
{
  this->length_.set (x);
}

void road::
length (const length_optional& x)
{
  this->length_ = x;
}

const road::id_optional& road::
id () const
{
  return this->id_;
}

road::id_optional& road::
id ()
{
  return this->id_;
}

void road::
id (const id_type& x)
{
  this->id_.set (x);
}

void road::
id (const id_optional& x)
{
  this->id_ = x;
}

void road::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}

const road::junction_optional& road::
junction () const
{
  return this->junction_;
}

road::junction_optional& road::
junction ()
{
  return this->junction_;
}

void road::
junction (const junction_type& x)
{
  this->junction_.set (x);
}

void road::
junction (const junction_optional& x)
{
  this->junction_ = x;
}

void road::
junction (::std::unique_ptr< junction_type > x)
{
  this->junction_.set (std::move (x));
}


// junction
// 

const junction::boundary_type& junction::
boundary () const
{
  return this->boundary_.get ();
}

junction::boundary_type& junction::
boundary ()
{
  return this->boundary_.get ();
}

void junction::
boundary (const boundary_type& x)
{
  this->boundary_.set (x);
}

void junction::
boundary (::std::unique_ptr< boundary_type > x)
{
  this->boundary_.set (std::move (x));
}

const junction::connection_sequence& junction::
connection () const
{
  return this->connection_;
}

junction::connection_sequence& junction::
connection ()
{
  return this->connection_;
}

void junction::
connection (const connection_sequence& s)
{
  this->connection_ = s;
}

const junction::name_optional& junction::
name () const
{
  return this->name_;
}

junction::name_optional& junction::
name ()
{
  return this->name_;
}

void junction::
name (const name_type& x)
{
  this->name_.set (x);
}

void junction::
name (const name_optional& x)
{
  this->name_ = x;
}

void junction::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const junction::id_optional& junction::
id () const
{
  return this->id_;
}

junction::id_optional& junction::
id ()
{
  return this->id_;
}

void junction::
id (const id_type& x)
{
  this->id_.set (x);
}

void junction::
id (const id_optional& x)
{
  this->id_ = x;
}


// borderInfo
// 

const borderInfo::lineType_optional& borderInfo::
lineType () const
{
  return this->lineType_;
}

borderInfo::lineType_optional& borderInfo::
lineType ()
{
  return this->lineType_;
}

void borderInfo::
lineType (const lineType_type& x)
{
  this->lineType_.set (x);
}

void borderInfo::
lineType (const lineType_optional& x)
{
  this->lineType_ = x;
}

void borderInfo::
lineType (::std::unique_ptr< lineType_type > x)
{
  this->lineType_.set (std::move (x));
}


// lanes
// 

const lanes::laneSection_sequence& lanes::
laneSection () const
{
  return this->laneSection_;
}

lanes::laneSection_sequence& lanes::
laneSection ()
{
  return this->laneSection_;
}

void lanes::
laneSection (const laneSection_sequence& s)
{
  this->laneSection_ = s;
}


// objects
// 

const objects::object_sequence& objects::
object () const
{
  return this->object_;
}

objects::object_sequence& objects::
object ()
{
  return this->object_;
}

void objects::
object (const object_sequence& s)
{
  this->object_ = s;
}


// boundary
// 

const boundary::geometry_type& boundary::
geometry () const
{
  return this->geometry_.get ();
}

boundary::geometry_type& boundary::
geometry ()
{
  return this->geometry_.get ();
}

void boundary::
geometry (const geometry_type& x)
{
  this->geometry_.set (x);
}

void boundary::
geometry (::std::unique_ptr< geometry_type > x)
{
  this->geometry_.set (std::move (x));
}


// connection
// 

const connection::id_optional& connection::
id () const
{
  return this->id_;
}

connection::id_optional& connection::
id ()
{
  return this->id_;
}

void connection::
id (const id_type& x)
{
  this->id_.set (x);
}

void connection::
id (const id_optional& x)
{
  this->id_ = x;
}

const connection::incomingRoad_optional& connection::
incomingRoad () const
{
  return this->incomingRoad_;
}

connection::incomingRoad_optional& connection::
incomingRoad ()
{
  return this->incomingRoad_;
}

void connection::
incomingRoad (const incomingRoad_type& x)
{
  this->incomingRoad_.set (x);
}

void connection::
incomingRoad (const incomingRoad_optional& x)
{
  this->incomingRoad_ = x;
}

void connection::
incomingRoad (::std::unique_ptr< incomingRoad_type > x)
{
  this->incomingRoad_.set (std::move (x));
}

const connection::outgoingRoad_optional& connection::
outgoingRoad () const
{
  return this->outgoingRoad_;
}

connection::outgoingRoad_optional& connection::
outgoingRoad ()
{
  return this->outgoingRoad_;
}

void connection::
outgoingRoad (const outgoingRoad_type& x)
{
  this->outgoingRoad_.set (x);
}

void connection::
outgoingRoad (const outgoingRoad_optional& x)
{
  this->outgoingRoad_ = x;
}

void connection::
outgoingRoad (::std::unique_ptr< outgoingRoad_type > x)
{
  this->outgoingRoad_.set (std::move (x));
}

const connection::connectingRoad_optional& connection::
connectingRoad () const
{
  return this->connectingRoad_;
}

connection::connectingRoad_optional& connection::
connectingRoad ()
{
  return this->connectingRoad_;
}

void connection::
connectingRoad (const connectingRoad_type& x)
{
  this->connectingRoad_.set (x);
}

void connection::
connectingRoad (const connectingRoad_optional& x)
{
  this->connectingRoad_ = x;
}

void connection::
connectingRoad (::std::unique_ptr< connectingRoad_type > x)
{
  this->connectingRoad_.set (std::move (x));
}

const connection::contactPoint_optional& connection::
contactPoint () const
{
  return this->contactPoint_;
}

connection::contactPoint_optional& connection::
contactPoint ()
{
  return this->contactPoint_;
}

void connection::
contactPoint (const contactPoint_type& x)
{
  this->contactPoint_.set (x);
}

void connection::
contactPoint (const contactPoint_optional& x)
{
  this->contactPoint_ = x;
}

void connection::
contactPoint (::std::unique_ptr< contactPoint_type > x)
{
  this->contactPoint_.set (std::move (x));
}

const connection::priority_optional& connection::
priority () const
{
  return this->priority_;
}

connection::priority_optional& connection::
priority ()
{
  return this->priority_;
}

void connection::
priority (const priority_type& x)
{
  this->priority_.set (x);
}

void connection::
priority (const priority_optional& x)
{
  this->priority_ = x;
}


// laneSection
// 

const laneSection::leftBoundary_type& laneSection::
leftBoundary () const
{
  return this->leftBoundary_.get ();
}

laneSection::leftBoundary_type& laneSection::
leftBoundary ()
{
  return this->leftBoundary_.get ();
}

void laneSection::
leftBoundary (const leftBoundary_type& x)
{
  this->leftBoundary_.set (x);
}

void laneSection::
leftBoundary (::std::unique_ptr< leftBoundary_type > x)
{
  this->leftBoundary_.set (std::move (x));
}

const laneSection::rightBoundary_type& laneSection::
rightBoundary () const
{
  return this->rightBoundary_.get ();
}

laneSection::rightBoundary_type& laneSection::
rightBoundary ()
{
  return this->rightBoundary_.get ();
}

void laneSection::
rightBoundary (const rightBoundary_type& x)
{
  this->rightBoundary_.set (x);
}

void laneSection::
rightBoundary (::std::unique_ptr< rightBoundary_type > x)
{
  this->rightBoundary_.set (std::move (x));
}

const laneSection::left_type& laneSection::
left () const
{
  return this->left_.get ();
}

laneSection::left_type& laneSection::
left ()
{
  return this->left_.get ();
}

void laneSection::
left (const left_type& x)
{
  this->left_.set (x);
}

void laneSection::
left (::std::unique_ptr< left_type > x)
{
  this->left_.set (std::move (x));
}

const laneSection::center_type& laneSection::
center () const
{
  return this->center_.get ();
}

laneSection::center_type& laneSection::
center ()
{
  return this->center_.get ();
}

void laneSection::
center (const center_type& x)
{
  this->center_.set (x);
}

void laneSection::
center (::std::unique_ptr< center_type > x)
{
  this->center_.set (std::move (x));
}

const laneSection::right_type& laneSection::
right () const
{
  return this->right_.get ();
}

laneSection::right_type& laneSection::
right ()
{
  return this->right_.get ();
}

void laneSection::
right (const right_type& x)
{
  this->right_.set (x);
}

void laneSection::
right (::std::unique_ptr< right_type > x)
{
  this->right_.set (std::move (x));
}

const laneSection::singleSide_optional& laneSection::
singleSide () const
{
  return this->singleSide_;
}

laneSection::singleSide_optional& laneSection::
singleSide ()
{
  return this->singleSide_;
}

void laneSection::
singleSide (const singleSide_type& x)
{
  this->singleSide_.set (x);
}

void laneSection::
singleSide (const singleSide_optional& x)
{
  this->singleSide_ = x;
}

void laneSection::
singleSide (::std::unique_ptr< singleSide_type > x)
{
  this->singleSide_.set (std::move (x));
}


// object
// 

const object::geometry_type& object::
geometry () const
{
  return this->geometry_.get ();
}

object::geometry_type& object::
geometry ()
{
  return this->geometry_.get ();
}

void object::
geometry (const geometry_type& x)
{
  this->geometry_.set (x);
}

void object::
geometry (::std::unique_ptr< geometry_type > x)
{
  this->geometry_.set (std::move (x));
}

const object::id_optional& object::
id () const
{
  return this->id_;
}

object::id_optional& object::
id ()
{
  return this->id_;
}

void object::
id (const id_type& x)
{
  this->id_.set (x);
}

void object::
id (const id_optional& x)
{
  this->id_ = x;
}

const object::type_optional& object::
type () const
{
  return this->type_;
}

object::type_optional& object::
type ()
{
  return this->type_;
}

void object::
type (const type_type& x)
{
  this->type_.set (x);
}

void object::
type (const type_optional& x)
{
  this->type_ = x;
}

void object::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// link_t
//

link_t::
link_t (const predecessor_type& predecessor,
        const successor_type& successor)
: ::xml_schema::type (),
  predecessor_ (predecessor, this),
  successor_ (successor, this)
{
}

link_t::
link_t (::std::unique_ptr< predecessor_type > predecessor,
        ::std::unique_ptr< successor_type > successor)
: ::xml_schema::type (),
  predecessor_ (std::move (predecessor), this),
  successor_ (std::move (successor), this)
{
}

link_t::
link_t (const link_t& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  predecessor_ (x.predecessor_, f, this),
  successor_ (x.successor_, f, this)
{
}

link_t::
link_t (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  predecessor_ (this),
  successor_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void link_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // predecessor
    //
    if (n.name () == "predecessor" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< predecessor_type > r (
        predecessor_traits::create (i, f, this));

      if (!predecessor_.present ())
      {
        this->predecessor_.set (::std::move (r));
        continue;
      }
    }

    // successor
    //
    if (n.name () == "successor" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< successor_type > r (
        successor_traits::create (i, f, this));

      if (!successor_.present ())
      {
        this->successor_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!predecessor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "predecessor",
      "");
  }

  if (!successor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "successor",
      "");
  }
}

link_t* link_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class link_t (*this, f, c);
}

link_t& link_t::
operator= (const link_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->predecessor_ = x.predecessor_;
    this->successor_ = x.successor_;
  }

  return *this;
}

link_t::
~link_t ()
{
}

// elementType
//

elementType::
elementType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_elementType_convert ();
}

elementType::
elementType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_elementType_convert ();
}

elementType::
elementType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_elementType_convert ();
}

elementType* elementType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class elementType (*this, f, c);
}

elementType::value elementType::
_xsd_elementType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_elementType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_elementType_indexes_,
                    _xsd_elementType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_elementType_indexes_ + 2 || _xsd_elementType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const elementType::
_xsd_elementType_literals_[2] =
{
  "road",
  "junction"
};

const elementType::value elementType::
_xsd_elementType_indexes_[2] =
{
  ::elementType::junction,
  ::elementType::road
};

// contactPoint
//

contactPoint::
contactPoint (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_contactPoint_convert ();
}

contactPoint::
contactPoint (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_contactPoint_convert ();
}

contactPoint::
contactPoint (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_contactPoint_convert ();
}

contactPoint* contactPoint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class contactPoint (*this, f, c);
}

contactPoint::value contactPoint::
_xsd_contactPoint_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_contactPoint_literals_);
  const value* i (::std::lower_bound (
                    _xsd_contactPoint_indexes_,
                    _xsd_contactPoint_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_contactPoint_indexes_ + 2 || _xsd_contactPoint_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const contactPoint::
_xsd_contactPoint_literals_[2] =
{
  "start",
  "end"
};

const contactPoint::value contactPoint::
_xsd_contactPoint_indexes_[2] =
{
  ::contactPoint::end,
  ::contactPoint::start
};

// singleSide
//

singleSide::
singleSide (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_singleSide_convert ();
}

singleSide::
singleSide (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_singleSide_convert ();
}

singleSide::
singleSide (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_singleSide_convert ();
}

singleSide* singleSide::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class singleSide (*this, f, c);
}

singleSide::value singleSide::
_xsd_singleSide_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_singleSide_literals_);
  const value* i (::std::lower_bound (
                    _xsd_singleSide_indexes_,
                    _xsd_singleSide_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_singleSide_indexes_ + 2 || _xsd_singleSide_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const singleSide::
_xsd_singleSide_literals_[2] =
{
  "true",
  "false"
};

const singleSide::value singleSide::
_xsd_singleSide_indexes_[2] =
{
  ::singleSide::false_,
  ::singleSide::true_
};

// roadBoundary
//

roadBoundary::
roadBoundary (const geometry_type& geometry)
: ::xml_schema::type (),
  geometry_ (geometry, this)
{
}

roadBoundary::
roadBoundary (::std::unique_ptr< geometry_type > geometry)
: ::xml_schema::type (),
  geometry_ (std::move (geometry), this)
{
}

roadBoundary::
roadBoundary (const roadBoundary& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  geometry_ (x.geometry_, f, this)
{
}

roadBoundary::
roadBoundary (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  geometry_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void roadBoundary::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geometry
    //
    if (n.name () == "geometry" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< geometry_type > r (
        geometry_traits::create (i, f, this));

      if (!geometry_.present ())
      {
        this->geometry_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!geometry_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "geometry",
      "");
  }
}

roadBoundary* roadBoundary::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class roadBoundary (*this, f, c);
}

roadBoundary& roadBoundary::
operator= (const roadBoundary& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->geometry_ = x.geometry_;
  }

  return *this;
}

roadBoundary::
~roadBoundary ()
{
}

// geometry
//

geometry::
geometry ()
: ::xml_schema::type (),
  point_ (this)
{
}

geometry::
geometry (const geometry& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  point_ (x.point_, f, this)
{
}

geometry::
geometry (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  point_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void geometry::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // point
    //
    if (n.name () == "point" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< point_type > r (
        point_traits::create (i, f, this));

      this->point_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

geometry* geometry::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class geometry (*this, f, c);
}

geometry& geometry::
operator= (const geometry& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->point_ = x.point_;
  }

  return *this;
}

geometry::
~geometry ()
{
}

// halfRoad
//

halfRoad::
halfRoad ()
: ::xml_schema::type (),
  lane_ (this)
{
}

halfRoad::
halfRoad (const halfRoad& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lane_ (x.lane_, f, this)
{
}

halfRoad::
halfRoad (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lane_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void halfRoad::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lane
    //
    if (n.name () == "lane" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lane_type > r (
        lane_traits::create (i, f, this));

      this->lane_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

halfRoad* halfRoad::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class halfRoad (*this, f, c);
}

halfRoad& halfRoad::
operator= (const halfRoad& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lane_ = x.lane_;
  }

  return *this;
}

halfRoad::
~halfRoad ()
{
}

// centerRoad
//

centerRoad::
centerRoad (const lane_type& lane)
: ::xml_schema::type (),
  lane_ (lane, this)
{
}

centerRoad::
centerRoad (::std::unique_ptr< lane_type > lane)
: ::xml_schema::type (),
  lane_ (std::move (lane), this)
{
}

centerRoad::
centerRoad (const centerRoad& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lane_ (x.lane_, f, this)
{
}

centerRoad::
centerRoad (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lane_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void centerRoad::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lane
    //
    if (n.name () == "lane" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lane_type > r (
        lane_traits::create (i, f, this));

      if (!lane_.present ())
      {
        this->lane_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!lane_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "lane",
      "");
  }
}

centerRoad* centerRoad::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class centerRoad (*this, f, c);
}

centerRoad& centerRoad::
operator= (const centerRoad& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lane_ = x.lane_;
  }

  return *this;
}

centerRoad::
~centerRoad ()
{
}

// lane
//

lane::
lane (const link_type& link,
      const border_type& border)
: ::xml_schema::type (),
  link_ (link, this),
  centerLine_ (this),
  leftBorder_ (this),
  border_ (border, this),
  speed_ (this),
  id_ (this),
  type_ (this),
  turnType_ (this)
{
}

lane::
lane (::std::unique_ptr< link_type > link,
      ::std::unique_ptr< border_type > border)
: ::xml_schema::type (),
  link_ (std::move (link), this),
  centerLine_ (this),
  leftBorder_ (this),
  border_ (std::move (border), this),
  speed_ (this),
  id_ (this),
  type_ (this),
  turnType_ (this)
{
}

lane::
lane (const lane& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  link_ (x.link_, f, this),
  centerLine_ (x.centerLine_, f, this),
  leftBorder_ (x.leftBorder_, f, this),
  border_ (x.border_, f, this),
  speed_ (x.speed_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this),
  turnType_ (x.turnType_, f, this)
{
}

lane::
lane (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  link_ (this),
  centerLine_ (this),
  leftBorder_ (this),
  border_ (this),
  speed_ (this),
  id_ (this),
  type_ (this),
  turnType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void lane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< link_type > r (
        link_traits::create (i, f, this));

      if (!link_.present ())
      {
        this->link_.set (::std::move (r));
        continue;
      }
    }

    // centerLine
    //
    if (n.name () == "centerLine" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< centerLine_type > r (
        centerLine_traits::create (i, f, this));

      if (!this->centerLine_)
      {
        this->centerLine_.set (::std::move (r));
        continue;
      }
    }

    // leftBorder
    //
    if (n.name () == "leftBorder" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< leftBorder_type > r (
        leftBorder_traits::create (i, f, this));

      if (!this->leftBorder_)
      {
        this->leftBorder_.set (::std::move (r));
        continue;
      }
    }

    // border
    //
    if (n.name () == "border" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< border_type > r (
        border_traits::create (i, f, this));

      if (!border_.present ())
      {
        this->border_.set (::std::move (r));
        continue;
      }
    }

    // speed
    //
    if (n.name () == "speed" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< speed_type > r (
        speed_traits::create (i, f, this));

      if (!this->speed_)
      {
        this->speed_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!link_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "link",
      "");
  }

  if (!border_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "border",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "turnType" && n.namespace_ ().empty ())
    {
      this->turnType_.set (turnType_traits::create (i, f, this));
      continue;
    }
  }
}

lane* lane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lane (*this, f, c);
}

lane& lane::
operator= (const lane& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->link_ = x.link_;
    this->centerLine_ = x.centerLine_;
    this->leftBorder_ = x.leftBorder_;
    this->border_ = x.border_;
    this->speed_ = x.speed_;
    this->id_ = x.id_;
    this->type_ = x.type_;
    this->turnType_ = x.turnType_;
  }

  return *this;
}

lane::
~lane ()
{
}

// borderType
//

borderType::
borderType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_borderType_convert ();
}

borderType::
borderType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_borderType_convert ();
}

borderType::
borderType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_borderType_convert ();
}

borderType* borderType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class borderType (*this, f, c);
}

borderType::value borderType::
_xsd_borderType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_borderType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_borderType_indexes_,
                    _xsd_borderType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_borderType_indexes_ + 2 || _xsd_borderType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const borderType::
_xsd_borderType_literals_[2] =
{
  "true",
  "false"
};

const borderType::value borderType::
_xsd_borderType_indexes_[2] =
{
  ::borderType::false_,
  ::borderType::true_
};

// laneType
//

laneType::
laneType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_laneType_convert ();
}

laneType::
laneType (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_laneType_convert ();
}

laneType::
laneType (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_laneType_convert ();
}

laneType* laneType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class laneType (*this, f, c);
}

laneType::value laneType::
_xsd_laneType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_laneType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_laneType_indexes_,
                    _xsd_laneType_indexes_ + 22,
                    *this,
                    c));

  if (i == _xsd_laneType_indexes_ + 22 || _xsd_laneType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const laneType::
_xsd_laneType_literals_[22] =
{
  "",
  "none",
  "driving",
  "stop",
  "shoulder",
  "biking",
  "sidewalk",
  "border",
  "restricted",
  "parking",
  "bidirectional",
  "median",
  "special1",
  "special2",
  "special3",
  "roadWorks",
  "tram",
  "rail",
  "entry",
  "exit",
  "offRamp",
  "onRamp"
};

const laneType::value laneType::
_xsd_laneType_indexes_[22] =
{
  ::laneType::empty,
  ::laneType::bidirectional,
  ::laneType::biking,
  ::laneType::border,
  ::laneType::driving,
  ::laneType::entry,
  ::laneType::exit,
  ::laneType::median,
  ::laneType::none,
  ::laneType::offRamp,
  ::laneType::onRamp,
  ::laneType::parking,
  ::laneType::rail,
  ::laneType::restricted,
  ::laneType::roadWorks,
  ::laneType::shoulder,
  ::laneType::sidewalk,
  ::laneType::special1,
  ::laneType::special2,
  ::laneType::special3,
  ::laneType::stop,
  ::laneType::tram
};

// objectType
//

objectType::
objectType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_objectType_convert ();
}

objectType::
objectType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_objectType_convert ();
}

objectType::
objectType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_objectType_convert ();
}

objectType* objectType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class objectType (*this, f, c);
}

objectType::value objectType::
_xsd_objectType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_objectType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_objectType_indexes_,
                    _xsd_objectType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_objectType_indexes_ + 3 || _xsd_objectType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const objectType::
_xsd_objectType_literals_[3] =
{
  "startline",
  "stopline",
  "lamp"
};

const objectType::value objectType::
_xsd_objectType_indexes_[3] =
{
  ::objectType::lamp,
  ::objectType::startline,
  ::objectType::stopline
};

// OpenDRIVE
//

OpenDRIVE::
OpenDRIVE (const header_type& header)
: ::xml_schema::type (),
  header_ (header, this),
  road_ (this),
  junction_ (this)
{
}

OpenDRIVE::
OpenDRIVE (::std::unique_ptr< header_type > header)
: ::xml_schema::type (),
  header_ (std::move (header), this),
  road_ (this),
  junction_ (this)
{
}

OpenDRIVE::
OpenDRIVE (const OpenDRIVE& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  header_ (x.header_, f, this),
  road_ (x.road_, f, this),
  junction_ (x.junction_, f, this)
{
}

OpenDRIVE::
OpenDRIVE (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  header_ (this),
  road_ (this),
  junction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void OpenDRIVE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // header
    //
    if (n.name () == "header" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< header_type > r (
        header_traits::create (i, f, this));

      if (!header_.present ())
      {
        this->header_.set (::std::move (r));
        continue;
      }
    }

    // road
    //
    if (n.name () == "road" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< road_type > r (
        road_traits::create (i, f, this));

      this->road_.push_back (::std::move (r));
      continue;
    }

    // junction
    //
    if (n.name () == "junction" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< junction_type > r (
        junction_traits::create (i, f, this));

      this->junction_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!header_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "header",
      "");
  }
}

OpenDRIVE* OpenDRIVE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OpenDRIVE (*this, f, c);
}

OpenDRIVE& OpenDRIVE::
operator= (const OpenDRIVE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->header_ = x.header_;
    this->road_ = x.road_;
    this->junction_ = x.junction_;
  }

  return *this;
}

OpenDRIVE::
~OpenDRIVE ()
{
}

// predecessor
//

predecessor::
predecessor ()
: ::xml_schema::type (),
  elementId_ (this),
  elementType_ (this),
  contactPoint_ (this),
  id_ (this)
{
}

predecessor::
predecessor (const predecessor& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  elementId_ (x.elementId_, f, this),
  elementType_ (x.elementType_, f, this),
  contactPoint_ (x.contactPoint_, f, this),
  id_ (x.id_, f, this)
{
}

predecessor::
predecessor (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  elementId_ (this),
  elementType_ (this),
  contactPoint_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void predecessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "elementId" && n.namespace_ ().empty ())
    {
      this->elementId_.set (elementId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementType" && n.namespace_ ().empty ())
    {
      this->elementType_.set (elementType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "contactPoint" && n.namespace_ ().empty ())
    {
      this->contactPoint_.set (contactPoint_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

predecessor* predecessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class predecessor (*this, f, c);
}

predecessor& predecessor::
operator= (const predecessor& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->elementId_ = x.elementId_;
    this->elementType_ = x.elementType_;
    this->contactPoint_ = x.contactPoint_;
    this->id_ = x.id_;
  }

  return *this;
}

predecessor::
~predecessor ()
{
}

// successor
//

successor::
successor ()
: ::xml_schema::type (),
  elementId_ (this),
  elementType_ (this),
  contactPoint_ (this),
  id_ (this)
{
}

successor::
successor (const successor& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  elementId_ (x.elementId_, f, this),
  elementType_ (x.elementType_, f, this),
  contactPoint_ (x.contactPoint_, f, this),
  id_ (x.id_, f, this)
{
}

successor::
successor (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  elementId_ (this),
  elementType_ (this),
  contactPoint_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void successor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "elementId" && n.namespace_ ().empty ())
    {
      this->elementId_.set (elementId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "elementType" && n.namespace_ ().empty ())
    {
      this->elementType_.set (elementType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "contactPoint" && n.namespace_ ().empty ())
    {
      this->contactPoint_.set (contactPoint_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

successor* successor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class successor (*this, f, c);
}

successor& successor::
operator= (const successor& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->elementId_ = x.elementId_;
    this->elementType_ = x.elementType_;
    this->contactPoint_ = x.contactPoint_;
    this->id_ = x.id_;
  }

  return *this;
}

successor::
~successor ()
{
}

// point
//

point::
point ()
: ::xml_schema::type (),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

point::
point (const point& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

point::
point (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void point::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }
}

point* point::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class point (*this, f, c);
}

point& point::
operator= (const point& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

point::
~point ()
{
}

// centerLine
//

centerLine::
centerLine ()
: ::xml_schema::type (),
  geometry_ (this)
{
}

centerLine::
centerLine (const centerLine& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  geometry_ (x.geometry_, f, this)
{
}

centerLine::
centerLine (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  geometry_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void centerLine::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geometry
    //
    if (n.name () == "geometry" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< geometry_type > r (
        geometry_traits::create (i, f, this));

      if (!this->geometry_)
      {
        this->geometry_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

centerLine* centerLine::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class centerLine (*this, f, c);
}

centerLine& centerLine::
operator= (const centerLine& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->geometry_ = x.geometry_;
  }

  return *this;
}

centerLine::
~centerLine ()
{
}

// leftBorder
//

leftBorder::
leftBorder (const geometry_type& geometry)
: ::xml_schema::type (),
  geometry_ (geometry, this)
{
}

leftBorder::
leftBorder (::std::unique_ptr< geometry_type > geometry)
: ::xml_schema::type (),
  geometry_ (std::move (geometry), this)
{
}

leftBorder::
leftBorder (const leftBorder& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  geometry_ (x.geometry_, f, this)
{
}

leftBorder::
leftBorder (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  geometry_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void leftBorder::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geometry
    //
    if (n.name () == "geometry" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< geometry_type > r (
        geometry_traits::create (i, f, this));

      if (!geometry_.present ())
      {
        this->geometry_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!geometry_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "geometry",
      "");
  }
}

leftBorder* leftBorder::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class leftBorder (*this, f, c);
}

leftBorder& leftBorder::
operator= (const leftBorder& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->geometry_ = x.geometry_;
  }

  return *this;
}

leftBorder::
~leftBorder ()
{
}

// border
//

border::
border (const geometry_type& geometry)
: ::xml_schema::type (),
  geometry_ (geometry, this),
  borderInfo_ (this),
  virtual__ (this)
{
}

border::
border (::std::unique_ptr< geometry_type > geometry)
: ::xml_schema::type (),
  geometry_ (std::move (geometry), this),
  borderInfo_ (this),
  virtual__ (this)
{
}

border::
border (const border& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  geometry_ (x.geometry_, f, this),
  borderInfo_ (x.borderInfo_, f, this),
  virtual__ (x.virtual__, f, this)
{
}

border::
border (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  geometry_ (this),
  borderInfo_ (this),
  virtual__ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void border::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geometry
    //
    if (n.name () == "geometry" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< geometry_type > r (
        geometry_traits::create (i, f, this));

      if (!geometry_.present ())
      {
        this->geometry_.set (::std::move (r));
        continue;
      }
    }

    // borderInfo
    //
    if (n.name () == "borderInfo" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< borderInfo_type > r (
        borderInfo_traits::create (i, f, this));

      this->borderInfo_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!geometry_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "geometry",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "virtual" && n.namespace_ ().empty ())
    {
      this->virtual__.set (virtual_traits::create (i, f, this));
      continue;
    }
  }
}

border* border::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class border (*this, f, c);
}

border& border::
operator= (const border& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->geometry_ = x.geometry_;
    this->borderInfo_ = x.borderInfo_;
    this->virtual__ = x.virtual__;
  }

  return *this;
}

border::
~border ()
{
}

// speed
//

speed::
speed ()
: ::xml_schema::type (),
  speedMin_ (this),
  speedMax_ (this)
{
}

speed::
speed (const speed& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  speedMin_ (x.speedMin_, f, this),
  speedMax_ (x.speedMax_, f, this)
{
}

speed::
speed (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  speedMin_ (this),
  speedMax_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void speed::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "speedMin" && n.namespace_ ().empty ())
    {
      this->speedMin_.set (speedMin_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "speedMax" && n.namespace_ ().empty ())
    {
      this->speedMax_.set (speedMax_traits::create (i, f, this));
      continue;
    }
  }
}

speed* speed::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class speed (*this, f, c);
}

speed& speed::
operator= (const speed& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->speedMin_ = x.speedMin_;
    this->speedMax_ = x.speedMax_;
  }

  return *this;
}

speed::
~speed ()
{
}

// header
//

header::
header ()
: ::xml_schema::type (),
  geoReference_ (this),
  revMajor_ (this),
  revMinor_ (this),
  name_ (this),
  version_ (this),
  date_ (this),
  north_ (this),
  south_ (this),
  east_ (this),
  west_ (this),
  maxRoad_ (this),
  maxJunc_ (this),
  maxPrg_ (this),
  vendor_ (this)
{
}

header::
header (const header& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  geoReference_ (x.geoReference_, f, this),
  revMajor_ (x.revMajor_, f, this),
  revMinor_ (x.revMinor_, f, this),
  name_ (x.name_, f, this),
  version_ (x.version_, f, this),
  date_ (x.date_, f, this),
  north_ (x.north_, f, this),
  south_ (x.south_, f, this),
  east_ (x.east_, f, this),
  west_ (x.west_, f, this),
  maxRoad_ (x.maxRoad_, f, this),
  maxJunc_ (x.maxJunc_, f, this),
  maxPrg_ (x.maxPrg_, f, this),
  vendor_ (x.vendor_, f, this)
{
}

header::
header (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  geoReference_ (this),
  revMajor_ (this),
  revMinor_ (this),
  name_ (this),
  version_ (this),
  date_ (this),
  north_ (this),
  south_ (this),
  east_ (this),
  west_ (this),
  maxRoad_ (this),
  maxJunc_ (this),
  maxPrg_ (this),
  vendor_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void header::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geoReference
    //
    if (n.name () == "geoReference" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< geoReference_type > r (
        geoReference_traits::create (i, f, this));

      if (!this->geoReference_)
      {
        this->geoReference_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "revMajor" && n.namespace_ ().empty ())
    {
      this->revMajor_.set (revMajor_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "revMinor" && n.namespace_ ().empty ())
    {
      this->revMinor_.set (revMinor_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "date" && n.namespace_ ().empty ())
    {
      this->date_.set (date_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "north" && n.namespace_ ().empty ())
    {
      this->north_.set (north_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "south" && n.namespace_ ().empty ())
    {
      this->south_.set (south_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "east" && n.namespace_ ().empty ())
    {
      this->east_.set (east_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "west" && n.namespace_ ().empty ())
    {
      this->west_.set (west_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "maxRoad" && n.namespace_ ().empty ())
    {
      this->maxRoad_.set (maxRoad_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "maxJunc" && n.namespace_ ().empty ())
    {
      this->maxJunc_.set (maxJunc_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "maxPrg" && n.namespace_ ().empty ())
    {
      this->maxPrg_.set (maxPrg_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vendor" && n.namespace_ ().empty ())
    {
      this->vendor_.set (vendor_traits::create (i, f, this));
      continue;
    }
  }
}

header* header::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class header (*this, f, c);
}

header& header::
operator= (const header& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->geoReference_ = x.geoReference_;
    this->revMajor_ = x.revMajor_;
    this->revMinor_ = x.revMinor_;
    this->name_ = x.name_;
    this->version_ = x.version_;
    this->date_ = x.date_;
    this->north_ = x.north_;
    this->south_ = x.south_;
    this->east_ = x.east_;
    this->west_ = x.west_;
    this->maxRoad_ = x.maxRoad_;
    this->maxJunc_ = x.maxJunc_;
    this->maxPrg_ = x.maxPrg_;
    this->vendor_ = x.vendor_;
  }

  return *this;
}

header::
~header ()
{
}

// road
//

road::
road (const link_type& link,
      const lanes_type& lanes,
      const objects_type& objects)
: ::xml_schema::type (),
  link_ (link, this),
  lanes_ (lanes, this),
  objects_ (objects, this),
  name_ (this),
  length_ (this),
  id_ (this),
  junction_ (this)
{
}

road::
road (::std::unique_ptr< link_type > link,
      ::std::unique_ptr< lanes_type > lanes,
      ::std::unique_ptr< objects_type > objects)
: ::xml_schema::type (),
  link_ (std::move (link), this),
  lanes_ (std::move (lanes), this),
  objects_ (std::move (objects), this),
  name_ (this),
  length_ (this),
  id_ (this),
  junction_ (this)
{
}

road::
road (const road& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  link_ (x.link_, f, this),
  lanes_ (x.lanes_, f, this),
  objects_ (x.objects_, f, this),
  name_ (x.name_, f, this),
  length_ (x.length_, f, this),
  id_ (x.id_, f, this),
  junction_ (x.junction_, f, this)
{
}

road::
road (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  link_ (this),
  lanes_ (this),
  objects_ (this),
  name_ (this),
  length_ (this),
  id_ (this),
  junction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void road::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< link_type > r (
        link_traits::create (i, f, this));

      if (!link_.present ())
      {
        this->link_.set (::std::move (r));
        continue;
      }
    }

    // lanes
    //
    if (n.name () == "lanes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lanes_type > r (
        lanes_traits::create (i, f, this));

      if (!lanes_.present ())
      {
        this->lanes_.set (::std::move (r));
        continue;
      }
    }

    // objects
    //
    if (n.name () == "objects" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< objects_type > r (
        objects_traits::create (i, f, this));

      if (!objects_.present ())
      {
        this->objects_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!link_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "link",
      "");
  }

  if (!lanes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "lanes",
      "");
  }

  if (!objects_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "objects",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "junction" && n.namespace_ ().empty ())
    {
      this->junction_.set (junction_traits::create (i, f, this));
      continue;
    }
  }
}

road* road::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class road (*this, f, c);
}

road& road::
operator= (const road& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->link_ = x.link_;
    this->lanes_ = x.lanes_;
    this->objects_ = x.objects_;
    this->name_ = x.name_;
    this->length_ = x.length_;
    this->id_ = x.id_;
    this->junction_ = x.junction_;
  }

  return *this;
}

road::
~road ()
{
}

// junction
//

junction::
junction (const boundary_type& boundary)
: ::xml_schema::type (),
  boundary_ (boundary, this),
  connection_ (this),
  name_ (this),
  id_ (this)
{
}

junction::
junction (::std::unique_ptr< boundary_type > boundary)
: ::xml_schema::type (),
  boundary_ (std::move (boundary), this),
  connection_ (this),
  name_ (this),
  id_ (this)
{
}

junction::
junction (const junction& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  boundary_ (x.boundary_, f, this),
  connection_ (x.connection_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this)
{
}

junction::
junction (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  boundary_ (this),
  connection_ (this),
  name_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void junction::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // boundary
    //
    if (n.name () == "boundary" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundary_type > r (
        boundary_traits::create (i, f, this));

      if (!boundary_.present ())
      {
        this->boundary_.set (::std::move (r));
        continue;
      }
    }

    // connection
    //
    if (n.name () == "connection" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< connection_type > r (
        connection_traits::create (i, f, this));

      this->connection_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!boundary_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

junction* junction::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class junction (*this, f, c);
}

junction& junction::
operator= (const junction& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->boundary_ = x.boundary_;
    this->connection_ = x.connection_;
    this->name_ = x.name_;
    this->id_ = x.id_;
  }

  return *this;
}

junction::
~junction ()
{
}

// borderInfo
//

borderInfo::
borderInfo ()
: ::xml_schema::type (),
  lineType_ (this)
{
}

borderInfo::
borderInfo (const borderInfo& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lineType_ (x.lineType_, f, this)
{
}

borderInfo::
borderInfo (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lineType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void borderInfo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "lineType" && n.namespace_ ().empty ())
    {
      this->lineType_.set (lineType_traits::create (i, f, this));
      continue;
    }
  }
}

borderInfo* borderInfo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class borderInfo (*this, f, c);
}

borderInfo& borderInfo::
operator= (const borderInfo& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lineType_ = x.lineType_;
  }

  return *this;
}

borderInfo::
~borderInfo ()
{
}

// lanes
//

lanes::
lanes ()
: ::xml_schema::type (),
  laneSection_ (this)
{
}

lanes::
lanes (const lanes& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  laneSection_ (x.laneSection_, f, this)
{
}

lanes::
lanes (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  laneSection_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void lanes::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // laneSection
    //
    if (n.name () == "laneSection" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< laneSection_type > r (
        laneSection_traits::create (i, f, this));

      this->laneSection_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

lanes* lanes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lanes (*this, f, c);
}

lanes& lanes::
operator= (const lanes& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->laneSection_ = x.laneSection_;
  }

  return *this;
}

lanes::
~lanes ()
{
}

// objects
//

objects::
objects ()
: ::xml_schema::type (),
  object_ (this)
{
}

objects::
objects (const objects& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  object_ (x.object_, f, this)
{
}

objects::
objects (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  object_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void objects::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // object
    //
    if (n.name () == "object" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< object_type > r (
        object_traits::create (i, f, this));

      this->object_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

objects* objects::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class objects (*this, f, c);
}

objects& objects::
operator= (const objects& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->object_ = x.object_;
  }

  return *this;
}

objects::
~objects ()
{
}

// boundary
//

boundary::
boundary (const geometry_type& geometry)
: ::xml_schema::type (),
  geometry_ (geometry, this)
{
}

boundary::
boundary (::std::unique_ptr< geometry_type > geometry)
: ::xml_schema::type (),
  geometry_ (std::move (geometry), this)
{
}

boundary::
boundary (const boundary& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  geometry_ (x.geometry_, f, this)
{
}

boundary::
boundary (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  geometry_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boundary::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geometry
    //
    if (n.name () == "geometry" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< geometry_type > r (
        geometry_traits::create (i, f, this));

      if (!geometry_.present ())
      {
        this->geometry_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!geometry_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "geometry",
      "");
  }
}

boundary* boundary::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary (*this, f, c);
}

boundary& boundary::
operator= (const boundary& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->geometry_ = x.geometry_;
  }

  return *this;
}

boundary::
~boundary ()
{
}

// connection
//

connection::
connection ()
: ::xml_schema::type (),
  id_ (this),
  incomingRoad_ (this),
  outgoingRoad_ (this),
  connectingRoad_ (this),
  contactPoint_ (this),
  priority_ (this)
{
}

connection::
connection (const connection& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  incomingRoad_ (x.incomingRoad_, f, this),
  outgoingRoad_ (x.outgoingRoad_, f, this),
  connectingRoad_ (x.connectingRoad_, f, this),
  contactPoint_ (x.contactPoint_, f, this),
  priority_ (x.priority_, f, this)
{
}

connection::
connection (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (this),
  incomingRoad_ (this),
  outgoingRoad_ (this),
  connectingRoad_ (this),
  contactPoint_ (this),
  priority_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void connection::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "incomingRoad" && n.namespace_ ().empty ())
    {
      this->incomingRoad_.set (incomingRoad_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "outgoingRoad" && n.namespace_ ().empty ())
    {
      this->outgoingRoad_.set (outgoingRoad_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "connectingRoad" && n.namespace_ ().empty ())
    {
      this->connectingRoad_.set (connectingRoad_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "contactPoint" && n.namespace_ ().empty ())
    {
      this->contactPoint_.set (contactPoint_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "priority" && n.namespace_ ().empty ())
    {
      this->priority_.set (priority_traits::create (i, f, this));
      continue;
    }
  }
}

connection* connection::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class connection (*this, f, c);
}

connection& connection::
operator= (const connection& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->id_ = x.id_;
    this->incomingRoad_ = x.incomingRoad_;
    this->outgoingRoad_ = x.outgoingRoad_;
    this->connectingRoad_ = x.connectingRoad_;
    this->contactPoint_ = x.contactPoint_;
    this->priority_ = x.priority_;
  }

  return *this;
}

connection::
~connection ()
{
}

// laneSection
//

laneSection::
laneSection (const leftBoundary_type& leftBoundary,
             const rightBoundary_type& rightBoundary,
             const left_type& left,
             const center_type& center,
             const right_type& right)
: ::xml_schema::type (),
  leftBoundary_ (leftBoundary, this),
  rightBoundary_ (rightBoundary, this),
  left_ (left, this),
  center_ (center, this),
  right_ (right, this),
  singleSide_ (this)
{
}

laneSection::
laneSection (::std::unique_ptr< leftBoundary_type > leftBoundary,
             ::std::unique_ptr< rightBoundary_type > rightBoundary,
             ::std::unique_ptr< left_type > left,
             ::std::unique_ptr< center_type > center,
             ::std::unique_ptr< right_type > right)
: ::xml_schema::type (),
  leftBoundary_ (std::move (leftBoundary), this),
  rightBoundary_ (std::move (rightBoundary), this),
  left_ (std::move (left), this),
  center_ (std::move (center), this),
  right_ (std::move (right), this),
  singleSide_ (this)
{
}

laneSection::
laneSection (const laneSection& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  leftBoundary_ (x.leftBoundary_, f, this),
  rightBoundary_ (x.rightBoundary_, f, this),
  left_ (x.left_, f, this),
  center_ (x.center_, f, this),
  right_ (x.right_, f, this),
  singleSide_ (x.singleSide_, f, this)
{
}

laneSection::
laneSection (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  leftBoundary_ (this),
  rightBoundary_ (this),
  left_ (this),
  center_ (this),
  right_ (this),
  singleSide_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void laneSection::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // leftBoundary
    //
    if (n.name () == "leftBoundary" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< leftBoundary_type > r (
        leftBoundary_traits::create (i, f, this));

      if (!leftBoundary_.present ())
      {
        this->leftBoundary_.set (::std::move (r));
        continue;
      }
    }

    // rightBoundary
    //
    if (n.name () == "rightBoundary" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< rightBoundary_type > r (
        rightBoundary_traits::create (i, f, this));

      if (!rightBoundary_.present ())
      {
        this->rightBoundary_.set (::std::move (r));
        continue;
      }
    }

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< left_type > r (
        left_traits::create (i, f, this));

      if (!left_.present ())
      {
        this->left_.set (::std::move (r));
        continue;
      }
    }

    // center
    //
    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< center_type > r (
        center_traits::create (i, f, this));

      if (!center_.present ())
      {
        this->center_.set (::std::move (r));
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< right_type > r (
        right_traits::create (i, f, this));

      if (!right_.present ())
      {
        this->right_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!leftBoundary_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "leftBoundary",
      "");
  }

  if (!rightBoundary_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "rightBoundary",
      "");
  }

  if (!left_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "left",
      "");
  }

  if (!center_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "center",
      "");
  }

  if (!right_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "right",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "singleSide" && n.namespace_ ().empty ())
    {
      this->singleSide_.set (singleSide_traits::create (i, f, this));
      continue;
    }
  }
}

laneSection* laneSection::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class laneSection (*this, f, c);
}

laneSection& laneSection::
operator= (const laneSection& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->leftBoundary_ = x.leftBoundary_;
    this->rightBoundary_ = x.rightBoundary_;
    this->left_ = x.left_;
    this->center_ = x.center_;
    this->right_ = x.right_;
    this->singleSide_ = x.singleSide_;
  }

  return *this;
}

laneSection::
~laneSection ()
{
}

// object
//

object::
object (const geometry_type& geometry)
: ::xml_schema::type (),
  geometry_ (geometry, this),
  id_ (this),
  type_ (this)
{
}

object::
object (::std::unique_ptr< geometry_type > geometry)
: ::xml_schema::type (),
  geometry_ (std::move (geometry), this),
  id_ (this),
  type_ (this)
{
}

object::
object (const object& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  geometry_ (x.geometry_, f, this),
  id_ (x.id_, f, this),
  type_ (x.type_, f, this)
{
}

object::
object (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  geometry_ (this),
  id_ (this),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void object::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // geometry
    //
    if (n.name () == "geometry" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< geometry_type > r (
        geometry_traits::create (i, f, this));

      if (!geometry_.present ())
      {
        this->geometry_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!geometry_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "geometry",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }
}

object* object::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class object (*this, f, c);
}

object& object::
operator= (const object& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->geometry_ = x.geometry_;
    this->id_ = x.id_;
    this->type_ = x.type_;
  }

  return *this;
}

object::
~object ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::OpenDRIVE_ (isrc, f, p);
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::OpenDRIVE_ (isrc, f, p);
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::OpenDRIVE_ (isrc, h, f, p);
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::OpenDRIVE > (
    ::OpenDRIVE_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::OpenDRIVE > (
      ::OpenDRIVE_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "OpenDRIVE" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::OpenDRIVE > r (
      ::xsd::cxx::tree::traits< ::OpenDRIVE, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "OpenDRIVE",
    "");
}

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "OpenDRIVE" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::OpenDRIVE > r (
      ::xsd::cxx::tree::traits< ::OpenDRIVE, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "OpenDRIVE",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

