// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef OPEN_DRIVE_1_4H_HXX
#define OPEN_DRIVE_1_4H_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class link_t;
class elementType;
class contactPoint;
class singleSide;
class roadBoundary;
class geometry;
class halfRoad;
class centerRoad;
class lane;
class borderType;
class laneType;
class objectType;
class OpenDRIVE;
class predecessor;
class successor;
class point;
class centerLine;
class leftBorder;
class border;
class speed;
class header;
class road;
class junction;
class borderInfo;
class lanes;
class objects;
class boundary;
class connection;
class laneSection;
class object;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class link_t: public ::xml_schema::type
{
  public:
  // predecessor
  //
  typedef ::predecessor predecessor_type;
  typedef ::xsd::cxx::tree::traits< predecessor_type, char > predecessor_traits;

  const predecessor_type&
  predecessor () const;

  predecessor_type&
  predecessor ();

  void
  predecessor (const predecessor_type& x);

  void
  predecessor (::std::unique_ptr< predecessor_type > p);

  // successor
  //
  typedef ::successor successor_type;
  typedef ::xsd::cxx::tree::traits< successor_type, char > successor_traits;

  const successor_type&
  successor () const;

  successor_type&
  successor ();

  void
  successor (const successor_type& x);

  void
  successor (::std::unique_ptr< successor_type > p);

  // Constructors.
  //
  link_t (const predecessor_type&,
          const successor_type&);

  link_t (::std::unique_ptr< predecessor_type >,
          ::std::unique_ptr< successor_type >);

  link_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  link_t (const link_t& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual link_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  link_t&
  operator= (const link_t& x);

  virtual 
  ~link_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< predecessor_type > predecessor_;
  ::xsd::cxx::tree::one< successor_type > successor_;
};

class elementType: public ::xml_schema::string
{
  public:
  enum value
  {
    road,
    junction
  };

  elementType (value v);

  elementType (const char* v);

  elementType (const ::std::string& v);

  elementType (const ::xml_schema::string& v);

  elementType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  elementType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  elementType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  elementType (const elementType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual elementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  elementType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_elementType_convert ();
  }

  protected:
  value
  _xsd_elementType_convert () const;

  public:
  static const char* const _xsd_elementType_literals_[2];
  static const value _xsd_elementType_indexes_[2];
};

class contactPoint: public ::xml_schema::string
{
  public:
  enum value
  {
    start,
    end
  };

  contactPoint (value v);

  contactPoint (const char* v);

  contactPoint (const ::std::string& v);

  contactPoint (const ::xml_schema::string& v);

  contactPoint (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  contactPoint (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  contactPoint (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  contactPoint (const contactPoint& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual contactPoint*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  contactPoint&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_contactPoint_convert ();
  }

  protected:
  value
  _xsd_contactPoint_convert () const;

  public:
  static const char* const _xsd_contactPoint_literals_[2];
  static const value _xsd_contactPoint_indexes_[2];
};

class singleSide: public ::xml_schema::string
{
  public:
  enum value
  {
    true_,
    false_
  };

  singleSide (value v);

  singleSide (const char* v);

  singleSide (const ::std::string& v);

  singleSide (const ::xml_schema::string& v);

  singleSide (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  singleSide (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  singleSide (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  singleSide (const singleSide& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual singleSide*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  singleSide&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_singleSide_convert ();
  }

  protected:
  value
  _xsd_singleSide_convert () const;

  public:
  static const char* const _xsd_singleSide_literals_[2];
  static const value _xsd_singleSide_indexes_[2];
};

class roadBoundary: public ::xml_schema::type
{
  public:
  // geometry
  //
  typedef ::geometry geometry_type;
  typedef ::xsd::cxx::tree::traits< geometry_type, char > geometry_traits;

  const geometry_type&
  geometry () const;

  geometry_type&
  geometry ();

  void
  geometry (const geometry_type& x);

  void
  geometry (::std::unique_ptr< geometry_type > p);

  // Constructors.
  //
  roadBoundary (const geometry_type&);

  roadBoundary (::std::unique_ptr< geometry_type >);

  roadBoundary (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  roadBoundary (const roadBoundary& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual roadBoundary*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  roadBoundary&
  operator= (const roadBoundary& x);

  virtual 
  ~roadBoundary ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< geometry_type > geometry_;
};

class geometry: public ::xml_schema::type
{
  public:
  // point
  //
  typedef ::point point_type;
  typedef ::xsd::cxx::tree::sequence< point_type > point_sequence;
  typedef point_sequence::iterator point_iterator;
  typedef point_sequence::const_iterator point_const_iterator;
  typedef ::xsd::cxx::tree::traits< point_type, char > point_traits;

  const point_sequence&
  point () const;

  point_sequence&
  point ();

  void
  point (const point_sequence& s);

  // Constructors.
  //
  geometry ();

  geometry (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  geometry (const geometry& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual geometry*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  geometry&
  operator= (const geometry& x);

  virtual 
  ~geometry ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  point_sequence point_;
};

class halfRoad: public ::xml_schema::type
{
  public:
  // lane
  //
  typedef ::lane lane_type;
  typedef ::xsd::cxx::tree::sequence< lane_type > lane_sequence;
  typedef lane_sequence::iterator lane_iterator;
  typedef lane_sequence::const_iterator lane_const_iterator;
  typedef ::xsd::cxx::tree::traits< lane_type, char > lane_traits;

  const lane_sequence&
  lane () const;

  lane_sequence&
  lane ();

  void
  lane (const lane_sequence& s);

  // Constructors.
  //
  halfRoad ();

  halfRoad (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  halfRoad (const halfRoad& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual halfRoad*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  halfRoad&
  operator= (const halfRoad& x);

  virtual 
  ~halfRoad ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  lane_sequence lane_;
};

class centerRoad: public ::xml_schema::type
{
  public:
  // lane
  //
  typedef ::lane lane_type;
  typedef ::xsd::cxx::tree::traits< lane_type, char > lane_traits;

  const lane_type&
  lane () const;

  lane_type&
  lane ();

  void
  lane (const lane_type& x);

  void
  lane (::std::unique_ptr< lane_type > p);

  // Constructors.
  //
  centerRoad (const lane_type&);

  centerRoad (::std::unique_ptr< lane_type >);

  centerRoad (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  centerRoad (const centerRoad& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual centerRoad*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  centerRoad&
  operator= (const centerRoad& x);

  virtual 
  ~centerRoad ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< lane_type > lane_;
};

class lane: public ::xml_schema::type
{
  public:
  // link
  //
  typedef ::link_t link_type;
  typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

  const link_type&
  link () const;

  link_type&
  link ();

  void
  link (const link_type& x);

  void
  link (::std::unique_ptr< link_type > p);

  // centerLine
  //
  typedef ::centerLine centerLine_type;
  typedef ::xsd::cxx::tree::optional< centerLine_type > centerLine_optional;
  typedef ::xsd::cxx::tree::traits< centerLine_type, char > centerLine_traits;

  const centerLine_optional&
  centerLine () const;

  centerLine_optional&
  centerLine ();

  void
  centerLine (const centerLine_type& x);

  void
  centerLine (const centerLine_optional& x);

  void
  centerLine (::std::unique_ptr< centerLine_type > p);

  // leftBorder
  //
  typedef ::leftBorder leftBorder_type;
  typedef ::xsd::cxx::tree::optional< leftBorder_type > leftBorder_optional;
  typedef ::xsd::cxx::tree::traits< leftBorder_type, char > leftBorder_traits;

  const leftBorder_optional&
  leftBorder () const;

  leftBorder_optional&
  leftBorder ();

  void
  leftBorder (const leftBorder_type& x);

  void
  leftBorder (const leftBorder_optional& x);

  void
  leftBorder (::std::unique_ptr< leftBorder_type > p);

  // border
  //
  typedef ::border border_type;
  typedef ::xsd::cxx::tree::traits< border_type, char > border_traits;

  const border_type&
  border () const;

  border_type&
  border ();

  void
  border (const border_type& x);

  void
  border (::std::unique_ptr< border_type > p);

  // speed
  //
  typedef ::speed speed_type;
  typedef ::xsd::cxx::tree::optional< speed_type > speed_optional;
  typedef ::xsd::cxx::tree::traits< speed_type, char > speed_traits;

  const speed_optional&
  speed () const;

  speed_optional&
  speed ();

  void
  speed (const speed_type& x);

  void
  speed (const speed_optional& x);

  void
  speed (::std::unique_ptr< speed_type > p);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // type
  //
  typedef ::laneType type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // turnType
  //
  typedef ::xml_schema::string turnType_type;
  typedef ::xsd::cxx::tree::optional< turnType_type > turnType_optional;
  typedef ::xsd::cxx::tree::traits< turnType_type, char > turnType_traits;

  const turnType_optional&
  turnType () const;

  turnType_optional&
  turnType ();

  void
  turnType (const turnType_type& x);

  void
  turnType (const turnType_optional& x);

  void
  turnType (::std::unique_ptr< turnType_type > p);

  // Constructors.
  //
  lane (const link_type&,
        const border_type&);

  lane (::std::unique_ptr< link_type >,
        ::std::unique_ptr< border_type >);

  lane (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  lane (const lane& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual lane*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  lane&
  operator= (const lane& x);

  virtual 
  ~lane ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< link_type > link_;
  centerLine_optional centerLine_;
  leftBorder_optional leftBorder_;
  ::xsd::cxx::tree::one< border_type > border_;
  speed_optional speed_;
  id_optional id_;
  type_optional type_;
  turnType_optional turnType_;
};

class borderType: public ::xml_schema::string
{
  public:
  enum value
  {
    true_,
    false_
  };

  borderType (value v);

  borderType (const char* v);

  borderType (const ::std::string& v);

  borderType (const ::xml_schema::string& v);

  borderType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  borderType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  borderType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  borderType (const borderType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual borderType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  borderType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_borderType_convert ();
  }

  protected:
  value
  _xsd_borderType_convert () const;

  public:
  static const char* const _xsd_borderType_literals_[2];
  static const value _xsd_borderType_indexes_[2];
};

class laneType: public ::xml_schema::string
{
  public:
  enum value
  {
    empty,
    none,
    driving,
    stop,
    shoulder,
    biking,
    sidewalk,
    border,
    restricted,
    parking,
    bidirectional,
    median,
    special1,
    special2,
    special3,
    roadWorks,
    tram,
    rail,
    entry,
    exit,
    offRamp,
    onRamp
  };

  laneType (value v);

  laneType (const char* v);

  laneType (const ::std::string& v);

  laneType (const ::xml_schema::string& v);

  laneType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  laneType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  laneType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  laneType (const laneType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual laneType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  laneType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_laneType_convert ();
  }

  protected:
  value
  _xsd_laneType_convert () const;

  public:
  static const char* const _xsd_laneType_literals_[22];
  static const value _xsd_laneType_indexes_[22];
};

class objectType: public ::xml_schema::string
{
  public:
  enum value
  {
    startline,
    stopline,
    lamp
  };

  objectType (value v);

  objectType (const char* v);

  objectType (const ::std::string& v);

  objectType (const ::xml_schema::string& v);

  objectType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  objectType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  objectType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  objectType (const objectType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual objectType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  objectType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_objectType_convert ();
  }

  protected:
  value
  _xsd_objectType_convert () const;

  public:
  static const char* const _xsd_objectType_literals_[3];
  static const value _xsd_objectType_indexes_[3];
};

class OpenDRIVE: public ::xml_schema::type
{
  public:
  // header
  //
  typedef ::header header_type;
  typedef ::xsd::cxx::tree::traits< header_type, char > header_traits;

  const header_type&
  header () const;

  header_type&
  header ();

  void
  header (const header_type& x);

  void
  header (::std::unique_ptr< header_type > p);

  // road
  //
  typedef ::road road_type;
  typedef ::xsd::cxx::tree::sequence< road_type > road_sequence;
  typedef road_sequence::iterator road_iterator;
  typedef road_sequence::const_iterator road_const_iterator;
  typedef ::xsd::cxx::tree::traits< road_type, char > road_traits;

  const road_sequence&
  road () const;

  road_sequence&
  road ();

  void
  road (const road_sequence& s);

  // junction
  //
  typedef ::junction junction_type;
  typedef ::xsd::cxx::tree::sequence< junction_type > junction_sequence;
  typedef junction_sequence::iterator junction_iterator;
  typedef junction_sequence::const_iterator junction_const_iterator;
  typedef ::xsd::cxx::tree::traits< junction_type, char > junction_traits;

  const junction_sequence&
  junction () const;

  junction_sequence&
  junction ();

  void
  junction (const junction_sequence& s);

  // Constructors.
  //
  OpenDRIVE (const header_type&);

  OpenDRIVE (::std::unique_ptr< header_type >);

  OpenDRIVE (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  OpenDRIVE (const OpenDRIVE& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual OpenDRIVE*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  OpenDRIVE&
  operator= (const OpenDRIVE& x);

  virtual 
  ~OpenDRIVE ();

    int activeRoadID;     // 记录当前相机所在的车道
    int activeSectionID;
    int activeLaneID;

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< header_type > header_;
  road_sequence road_;
  junction_sequence junction_;
};

class predecessor: public ::xml_schema::type
{
  public:
  // elementId
  //
  typedef ::xml_schema::string elementId_type;
  typedef ::xsd::cxx::tree::optional< elementId_type > elementId_optional;
  typedef ::xsd::cxx::tree::traits< elementId_type, char > elementId_traits;

  const elementId_optional&
  elementId () const;

  elementId_optional&
  elementId ();

  void
  elementId (const elementId_type& x);

  void
  elementId (const elementId_optional& x);

  void
  elementId (::std::unique_ptr< elementId_type > p);

  // elementType
  //
  typedef ::elementType elementType_type;
  typedef ::xsd::cxx::tree::optional< elementType_type > elementType_optional;
  typedef ::xsd::cxx::tree::traits< elementType_type, char > elementType_traits;

  const elementType_optional&
  elementType () const;

  elementType_optional&
  elementType ();

  void
  elementType (const elementType_type& x);

  void
  elementType (const elementType_optional& x);

  void
  elementType (::std::unique_ptr< elementType_type > p);

  // contactPoint
  //
  typedef ::contactPoint contactPoint_type;
  typedef ::xsd::cxx::tree::optional< contactPoint_type > contactPoint_optional;
  typedef ::xsd::cxx::tree::traits< contactPoint_type, char > contactPoint_traits;

  const contactPoint_optional&
  contactPoint () const;

  contactPoint_optional&
  contactPoint ();

  void
  contactPoint (const contactPoint_type& x);

  void
  contactPoint (const contactPoint_optional& x);

  void
  contactPoint (::std::unique_ptr< contactPoint_type > p);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // Constructors.
  //
  predecessor ();

  predecessor (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  predecessor (const predecessor& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual predecessor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  predecessor&
  operator= (const predecessor& x);

  virtual 
  ~predecessor ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  elementId_optional elementId_;
  elementType_optional elementType_;
  contactPoint_optional contactPoint_;
  id_optional id_;
};

class successor: public ::xml_schema::type
{
  public:
  // elementId
  //
  typedef ::xml_schema::string elementId_type;
  typedef ::xsd::cxx::tree::optional< elementId_type > elementId_optional;
  typedef ::xsd::cxx::tree::traits< elementId_type, char > elementId_traits;

  const elementId_optional&
  elementId () const;

  elementId_optional&
  elementId ();

  void
  elementId (const elementId_type& x);

  void
  elementId (const elementId_optional& x);

  void
  elementId (::std::unique_ptr< elementId_type > p);

  // elementType
  //
  typedef ::elementType elementType_type;
  typedef ::xsd::cxx::tree::optional< elementType_type > elementType_optional;
  typedef ::xsd::cxx::tree::traits< elementType_type, char > elementType_traits;

  const elementType_optional&
  elementType () const;

  elementType_optional&
  elementType ();

  void
  elementType (const elementType_type& x);

  void
  elementType (const elementType_optional& x);

  void
  elementType (::std::unique_ptr< elementType_type > p);

  // contactPoint
  //
  typedef ::contactPoint contactPoint_type;
  typedef ::xsd::cxx::tree::optional< contactPoint_type > contactPoint_optional;
  typedef ::xsd::cxx::tree::traits< contactPoint_type, char > contactPoint_traits;

  const contactPoint_optional&
  contactPoint () const;

  contactPoint_optional&
  contactPoint ();

  void
  contactPoint (const contactPoint_type& x);

  void
  contactPoint (const contactPoint_optional& x);

  void
  contactPoint (::std::unique_ptr< contactPoint_type > p);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // Constructors.
  //
  successor ();

  successor (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  successor (const successor& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual successor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  successor&
  operator= (const successor& x);

  virtual 
  ~successor ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  elementId_optional elementId_;
  elementType_optional elementType_;
  contactPoint_optional contactPoint_;
  id_optional id_;
};

class point: public ::xml_schema::type
{
  public:
  // x
  //
  typedef ::xml_schema::double_ x_type;
  typedef ::xsd::cxx::tree::optional< x_type > x_optional;
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  const x_optional&
  x () const;

  x_optional&
  x ();

  void
  x (const x_type& x);

  void
  x (const x_optional& x);

  // y
  //
  typedef ::xml_schema::double_ y_type;
  typedef ::xsd::cxx::tree::optional< y_type > y_optional;
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  const y_optional&
  y () const;

  y_optional&
  y ();

  void
  y (const y_type& x);

  void
  y (const y_optional& x);

  // z
  //
  typedef ::xml_schema::double_ z_type;
  typedef ::xsd::cxx::tree::optional< z_type > z_optional;
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

  const z_optional&
  z () const;

  z_optional&
  z ();

  void
  z (const z_type& x);

  void
  z (const z_optional& x);

  // Constructors.
  //
  point ();

  point (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  point (const point& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual point*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  point&
  operator= (const point& x);

  virtual 
  ~point ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  x_optional x_;
  y_optional y_;
  z_optional z_;
};

class centerLine: public ::xml_schema::type
{
  public:
  // geometry
  //
  typedef ::geometry geometry_type;
  typedef ::xsd::cxx::tree::optional< geometry_type > geometry_optional;
  typedef ::xsd::cxx::tree::traits< geometry_type, char > geometry_traits;

  const geometry_optional&
  geometry () const;

  geometry_optional&
  geometry ();

  void
  geometry (const geometry_type& x);

  void
  geometry (const geometry_optional& x);

  void
  geometry (::std::unique_ptr< geometry_type > p);

  // Constructors.
  //
  centerLine ();

  centerLine (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  centerLine (const centerLine& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual centerLine*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  centerLine&
  operator= (const centerLine& x);

  virtual 
  ~centerLine ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  geometry_optional geometry_;
};

class leftBorder: public ::xml_schema::type
{
  public:
  // geometry
  //
  typedef ::geometry geometry_type;
  typedef ::xsd::cxx::tree::traits< geometry_type, char > geometry_traits;

  const geometry_type&
  geometry () const;

  geometry_type&
  geometry ();

  void
  geometry (const geometry_type& x);

  void
  geometry (::std::unique_ptr< geometry_type > p);

  // Constructors.
  //
  leftBorder (const geometry_type&);

  leftBorder (::std::unique_ptr< geometry_type >);

  leftBorder (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  leftBorder (const leftBorder& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual leftBorder*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  leftBorder&
  operator= (const leftBorder& x);

  virtual 
  ~leftBorder ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< geometry_type > geometry_;
};

class border: public ::xml_schema::type
{
  public:
  // geometry
  //
  typedef ::geometry geometry_type;
  typedef ::xsd::cxx::tree::traits< geometry_type, char > geometry_traits;

  const geometry_type&
  geometry () const;

  geometry_type&
  geometry ();

  void
  geometry (const geometry_type& x);

  void
  geometry (::std::unique_ptr< geometry_type > p);

  // borderInfo
  //
  typedef ::borderInfo borderInfo_type;
  typedef ::xsd::cxx::tree::sequence< borderInfo_type > borderInfo_sequence;
  typedef borderInfo_sequence::iterator borderInfo_iterator;
  typedef borderInfo_sequence::const_iterator borderInfo_const_iterator;
  typedef ::xsd::cxx::tree::traits< borderInfo_type, char > borderInfo_traits;

  const borderInfo_sequence&
  borderInfo () const;

  borderInfo_sequence&
  borderInfo ();

  void
  borderInfo (const borderInfo_sequence& s);

  // virtual
  //
  typedef ::borderType virtual_type;
  typedef ::xsd::cxx::tree::optional< virtual_type > virtual_optional;
  typedef ::xsd::cxx::tree::traits< virtual_type, char > virtual_traits;

  const virtual_optional&
  virtual_ () const;

  virtual_optional&
  virtual_ ();

  void
  virtual_ (const virtual_type& x);

  void
  virtual_ (const virtual_optional& x);

  void
  virtual_ (::std::unique_ptr< virtual_type > p);

  // Constructors.
  //
  border (const geometry_type&);

  border (::std::unique_ptr< geometry_type >);

  border (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  border (const border& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual border*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  border&
  operator= (const border& x);

  virtual 
  ~border ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< geometry_type > geometry_;
  borderInfo_sequence borderInfo_;
  virtual_optional virtual__;
};

class speed: public ::xml_schema::type
{
  public:
  // speedMin
  //
  typedef ::xml_schema::unsigned_short speedMin_type;
  typedef ::xsd::cxx::tree::optional< speedMin_type > speedMin_optional;
  typedef ::xsd::cxx::tree::traits< speedMin_type, char > speedMin_traits;

  const speedMin_optional&
  speedMin () const;

  speedMin_optional&
  speedMin ();

  void
  speedMin (const speedMin_type& x);

  void
  speedMin (const speedMin_optional& x);

  // speedMax
  //
  typedef ::xml_schema::unsigned_short speedMax_type;
  typedef ::xsd::cxx::tree::optional< speedMax_type > speedMax_optional;
  typedef ::xsd::cxx::tree::traits< speedMax_type, char > speedMax_traits;

  const speedMax_optional&
  speedMax () const;

  speedMax_optional&
  speedMax ();

  void
  speedMax (const speedMax_type& x);

  void
  speedMax (const speedMax_optional& x);

  // Constructors.
  //
  speed ();

  speed (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  speed (const speed& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual speed*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  speed&
  operator= (const speed& x);

  virtual 
  ~speed ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  speedMin_optional speedMin_;
  speedMax_optional speedMax_;
};

class header: public ::xml_schema::type
{
  public:
  // geoReference
  //
  typedef ::xml_schema::string geoReference_type;
  typedef ::xsd::cxx::tree::optional< geoReference_type > geoReference_optional;
  typedef ::xsd::cxx::tree::traits< geoReference_type, char > geoReference_traits;

  const geoReference_optional&
  geoReference () const;

  geoReference_optional&
  geoReference ();

  void
  geoReference (const geoReference_type& x);

  void
  geoReference (const geoReference_optional& x);

  void
  geoReference (::std::unique_ptr< geoReference_type > p);

  // revMajor
  //
  typedef ::xml_schema::unsigned_short revMajor_type;
  typedef ::xsd::cxx::tree::optional< revMajor_type > revMajor_optional;
  typedef ::xsd::cxx::tree::traits< revMajor_type, char > revMajor_traits;

  const revMajor_optional&
  revMajor () const;

  revMajor_optional&
  revMajor ();

  void
  revMajor (const revMajor_type& x);

  void
  revMajor (const revMajor_optional& x);

  // revMinor
  //
  typedef ::xml_schema::unsigned_short revMinor_type;
  typedef ::xsd::cxx::tree::optional< revMinor_type > revMinor_optional;
  typedef ::xsd::cxx::tree::traits< revMinor_type, char > revMinor_traits;

  const revMinor_optional&
  revMinor () const;

  revMinor_optional&
  revMinor ();

  void
  revMinor (const revMinor_type& x);

  void
  revMinor (const revMinor_optional& x);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // version
  //
  typedef ::xml_schema::float_ version_type;
  typedef ::xsd::cxx::tree::optional< version_type > version_optional;
  typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

  const version_optional&
  version () const;

  version_optional&
  version ();

  void
  version (const version_type& x);

  void
  version (const version_optional& x);

  // date
  //
  typedef ::xml_schema::string date_type;
  typedef ::xsd::cxx::tree::optional< date_type > date_optional;
  typedef ::xsd::cxx::tree::traits< date_type, char > date_traits;

  const date_optional&
  date () const;

  date_optional&
  date ();

  void
  date (const date_type& x);

  void
  date (const date_optional& x);

  void
  date (::std::unique_ptr< date_type > p);

  // north
  //
  typedef ::xml_schema::double_ north_type;
  typedef ::xsd::cxx::tree::optional< north_type > north_optional;
  typedef ::xsd::cxx::tree::traits< north_type, char, ::xsd::cxx::tree::schema_type::double_ > north_traits;

  const north_optional&
  north () const;

  north_optional&
  north ();

  void
  north (const north_type& x);

  void
  north (const north_optional& x);

  // south
  //
  typedef ::xml_schema::double_ south_type;
  typedef ::xsd::cxx::tree::optional< south_type > south_optional;
  typedef ::xsd::cxx::tree::traits< south_type, char, ::xsd::cxx::tree::schema_type::double_ > south_traits;

  const south_optional&
  south () const;

  south_optional&
  south ();

  void
  south (const south_type& x);

  void
  south (const south_optional& x);

  // east
  //
  typedef ::xml_schema::double_ east_type;
  typedef ::xsd::cxx::tree::optional< east_type > east_optional;
  typedef ::xsd::cxx::tree::traits< east_type, char, ::xsd::cxx::tree::schema_type::double_ > east_traits;

  const east_optional&
  east () const;

  east_optional&
  east ();

  void
  east (const east_type& x);

  void
  east (const east_optional& x);

  // west
  //
  typedef ::xml_schema::double_ west_type;
  typedef ::xsd::cxx::tree::optional< west_type > west_optional;
  typedef ::xsd::cxx::tree::traits< west_type, char, ::xsd::cxx::tree::schema_type::double_ > west_traits;

  const west_optional&
  west () const;

  west_optional&
  west ();

  void
  west (const west_type& x);

  void
  west (const west_optional& x);

  // maxRoad
  //
  typedef ::xml_schema::unsigned_short maxRoad_type;
  typedef ::xsd::cxx::tree::optional< maxRoad_type > maxRoad_optional;
  typedef ::xsd::cxx::tree::traits< maxRoad_type, char > maxRoad_traits;

  const maxRoad_optional&
  maxRoad () const;

  maxRoad_optional&
  maxRoad ();

  void
  maxRoad (const maxRoad_type& x);

  void
  maxRoad (const maxRoad_optional& x);

  // maxJunc
  //
  typedef ::xml_schema::unsigned_short maxJunc_type;
  typedef ::xsd::cxx::tree::optional< maxJunc_type > maxJunc_optional;
  typedef ::xsd::cxx::tree::traits< maxJunc_type, char > maxJunc_traits;

  const maxJunc_optional&
  maxJunc () const;

  maxJunc_optional&
  maxJunc ();

  void
  maxJunc (const maxJunc_type& x);

  void
  maxJunc (const maxJunc_optional& x);

  // maxPrg
  //
  typedef ::xml_schema::unsigned_short maxPrg_type;
  typedef ::xsd::cxx::tree::optional< maxPrg_type > maxPrg_optional;
  typedef ::xsd::cxx::tree::traits< maxPrg_type, char > maxPrg_traits;

  const maxPrg_optional&
  maxPrg () const;

  maxPrg_optional&
  maxPrg ();

  void
  maxPrg (const maxPrg_type& x);

  void
  maxPrg (const maxPrg_optional& x);

  // vendor
  //
  typedef ::xml_schema::string vendor_type;
  typedef ::xsd::cxx::tree::optional< vendor_type > vendor_optional;
  typedef ::xsd::cxx::tree::traits< vendor_type, char > vendor_traits;

  const vendor_optional&
  vendor () const;

  vendor_optional&
  vendor ();

  void
  vendor (const vendor_type& x);

  void
  vendor (const vendor_optional& x);

  void
  vendor (::std::unique_ptr< vendor_type > p);

  // Constructors.
  //
  header ();

  header (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  header (const header& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual header*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  header&
  operator= (const header& x);

  virtual 
  ~header ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  geoReference_optional geoReference_;
  revMajor_optional revMajor_;
  revMinor_optional revMinor_;
  name_optional name_;
  version_optional version_;
  date_optional date_;
  north_optional north_;
  south_optional south_;
  east_optional east_;
  west_optional west_;
  maxRoad_optional maxRoad_;
  maxJunc_optional maxJunc_;
  maxPrg_optional maxPrg_;
  vendor_optional vendor_;
};

class road: public ::xml_schema::type
{
  public:
  // link
  //
  typedef ::link_t link_type;
  typedef ::xsd::cxx::tree::traits< link_type, char > link_traits;

  const link_type&
  link () const;

  link_type&
  link ();

  void
  link (const link_type& x);

  void
  link (::std::unique_ptr< link_type > p);

  // lanes
  //
  typedef ::lanes lanes_type;
  typedef ::xsd::cxx::tree::traits< lanes_type, char > lanes_traits;

  const lanes_type&
  lanes () const;

  lanes_type&
  lanes ();

  void
  lanes (const lanes_type& x);

  void
  lanes (::std::unique_ptr< lanes_type > p);

  // objects
  //
  typedef ::objects objects_type;
  typedef ::xsd::cxx::tree::traits< objects_type, char > objects_traits;

  const objects_type&
  objects () const;

  objects_type&
  objects ();

  void
  objects (const objects_type& x);

  void
  objects (::std::unique_ptr< objects_type > p);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // length
  //
  typedef ::xml_schema::double_ length_type;
  typedef ::xsd::cxx::tree::optional< length_type > length_optional;
  typedef ::xsd::cxx::tree::traits< length_type, char, ::xsd::cxx::tree::schema_type::double_ > length_traits;

  const length_optional&
  length () const;

  length_optional&
  length ();

  void
  length (const length_type& x);

  void
  length (const length_optional& x);

  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // junction
  //
  typedef ::xml_schema::string junction_type;
  typedef ::xsd::cxx::tree::optional< junction_type > junction_optional;
  typedef ::xsd::cxx::tree::traits< junction_type, char > junction_traits;

  const junction_optional&
  junction () const;

  junction_optional&
  junction ();

  void
  junction (const junction_type& x);

  void
  junction (const junction_optional& x);

  void
  junction (::std::unique_ptr< junction_type > p);

  // Constructors.
  //
  road (const link_type&,
        const lanes_type&,
        const objects_type&);

  road (::std::unique_ptr< link_type >,
        ::std::unique_ptr< lanes_type >,
        ::std::unique_ptr< objects_type >);

  road (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  road (const road& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual road*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  road&
  operator= (const road& x);

  virtual 
  ~road ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< link_type > link_;
  ::xsd::cxx::tree::one< lanes_type > lanes_;
  ::xsd::cxx::tree::one< objects_type > objects_;
  name_optional name_;
  length_optional length_;
  id_optional id_;
  junction_optional junction_;
};

class junction: public ::xml_schema::type
{
  public:
  // boundary
  //
  typedef ::boundary boundary_type;
  typedef ::xsd::cxx::tree::traits< boundary_type, char > boundary_traits;

  const boundary_type&
  boundary () const;

  boundary_type&
  boundary ();

  void
  boundary (const boundary_type& x);

  void
  boundary (::std::unique_ptr< boundary_type > p);

  // connection
  //
  typedef ::connection connection_type;
  typedef ::xsd::cxx::tree::sequence< connection_type > connection_sequence;
  typedef connection_sequence::iterator connection_iterator;
  typedef connection_sequence::const_iterator connection_const_iterator;
  typedef ::xsd::cxx::tree::traits< connection_type, char > connection_traits;

  const connection_sequence&
  connection () const;

  connection_sequence&
  connection ();

  void
  connection (const connection_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::optional< name_type > name_optional;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_optional&
  name () const;

  name_optional&
  name ();

  void
  name (const name_type& x);

  void
  name (const name_optional& x);

  void
  name (::std::unique_ptr< name_type > p);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // Constructors.
  //
  junction (const boundary_type&);

  junction (::std::unique_ptr< boundary_type >);

  junction (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  junction (const junction& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual junction*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  junction&
  operator= (const junction& x);

  virtual 
  ~junction ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< boundary_type > boundary_;
  connection_sequence connection_;
  name_optional name_;
  id_optional id_;
};

class borderInfo: public ::xml_schema::type
{
  public:
  // lineType
  //
  typedef ::xml_schema::string lineType_type;
  typedef ::xsd::cxx::tree::optional< lineType_type > lineType_optional;
  typedef ::xsd::cxx::tree::traits< lineType_type, char > lineType_traits;

  const lineType_optional&
  lineType () const;

  lineType_optional&
  lineType ();

  void
  lineType (const lineType_type& x);

  void
  lineType (const lineType_optional& x);

  void
  lineType (::std::unique_ptr< lineType_type > p);

  // Constructors.
  //
  borderInfo ();

  borderInfo (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  borderInfo (const borderInfo& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual borderInfo*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  borderInfo&
  operator= (const borderInfo& x);

  virtual 
  ~borderInfo ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  lineType_optional lineType_;
};

class lanes: public ::xml_schema::type
{
  public:
  // laneSection
  //
  typedef ::laneSection laneSection_type;
  typedef ::xsd::cxx::tree::sequence< laneSection_type > laneSection_sequence;
  typedef laneSection_sequence::iterator laneSection_iterator;
  typedef laneSection_sequence::const_iterator laneSection_const_iterator;
  typedef ::xsd::cxx::tree::traits< laneSection_type, char > laneSection_traits;

  const laneSection_sequence&
  laneSection () const;

  laneSection_sequence&
  laneSection ();

  void
  laneSection (const laneSection_sequence& s);

  // Constructors.
  //
  lanes ();

  lanes (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  lanes (const lanes& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual lanes*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  lanes&
  operator= (const lanes& x);

  virtual 
  ~lanes ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  laneSection_sequence laneSection_;
};

class objects: public ::xml_schema::type
{
  public:
  // object
  //
  typedef ::object object_type;
  typedef ::xsd::cxx::tree::sequence< object_type > object_sequence;
  typedef object_sequence::iterator object_iterator;
  typedef object_sequence::const_iterator object_const_iterator;
  typedef ::xsd::cxx::tree::traits< object_type, char > object_traits;

  const object_sequence&
  object () const;

  object_sequence&
  object ();

  void
  object (const object_sequence& s);

  // Constructors.
  //
  objects ();

  objects (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  objects (const objects& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual objects*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  objects&
  operator= (const objects& x);

  virtual 
  ~objects ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  object_sequence object_;
};

class boundary: public ::xml_schema::type
{
  public:
  // geometry
  //
  typedef ::geometry geometry_type;
  typedef ::xsd::cxx::tree::traits< geometry_type, char > geometry_traits;

  const geometry_type&
  geometry () const;

  geometry_type&
  geometry ();

  void
  geometry (const geometry_type& x);

  void
  geometry (::std::unique_ptr< geometry_type > p);

  // Constructors.
  //
  boundary (const geometry_type&);

  boundary (::std::unique_ptr< geometry_type >);

  boundary (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  boundary (const boundary& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual boundary*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  boundary&
  operator= (const boundary& x);

  virtual 
  ~boundary ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< geometry_type > geometry_;
};

class connection: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // incomingRoad
  //
  typedef ::xml_schema::string incomingRoad_type;
  typedef ::xsd::cxx::tree::optional< incomingRoad_type > incomingRoad_optional;
  typedef ::xsd::cxx::tree::traits< incomingRoad_type, char > incomingRoad_traits;

  const incomingRoad_optional&
  incomingRoad () const;

  incomingRoad_optional&
  incomingRoad ();

  void
  incomingRoad (const incomingRoad_type& x);

  void
  incomingRoad (const incomingRoad_optional& x);

  void
  incomingRoad (::std::unique_ptr< incomingRoad_type > p);

  // outgoingRoad
  //
  typedef ::xml_schema::string outgoingRoad_type;
  typedef ::xsd::cxx::tree::optional< outgoingRoad_type > outgoingRoad_optional;
  typedef ::xsd::cxx::tree::traits< outgoingRoad_type, char > outgoingRoad_traits;

  const outgoingRoad_optional&
  outgoingRoad () const;

  outgoingRoad_optional&
  outgoingRoad ();

  void
  outgoingRoad (const outgoingRoad_type& x);

  void
  outgoingRoad (const outgoingRoad_optional& x);

  void
  outgoingRoad (::std::unique_ptr< outgoingRoad_type > p);

  // connectingRoad
  //
  typedef ::xml_schema::string connectingRoad_type;
  typedef ::xsd::cxx::tree::optional< connectingRoad_type > connectingRoad_optional;
  typedef ::xsd::cxx::tree::traits< connectingRoad_type, char > connectingRoad_traits;

  const connectingRoad_optional&
  connectingRoad () const;

  connectingRoad_optional&
  connectingRoad ();

  void
  connectingRoad (const connectingRoad_type& x);

  void
  connectingRoad (const connectingRoad_optional& x);

  void
  connectingRoad (::std::unique_ptr< connectingRoad_type > p);

  // contactPoint
  //
  typedef ::contactPoint contactPoint_type;
  typedef ::xsd::cxx::tree::optional< contactPoint_type > contactPoint_optional;
  typedef ::xsd::cxx::tree::traits< contactPoint_type, char > contactPoint_traits;

  const contactPoint_optional&
  contactPoint () const;

  contactPoint_optional&
  contactPoint ();

  void
  contactPoint (const contactPoint_type& x);

  void
  contactPoint (const contactPoint_optional& x);

  void
  contactPoint (::std::unique_ptr< contactPoint_type > p);

  // priority
  //
  typedef ::xml_schema::int_ priority_type;
  typedef ::xsd::cxx::tree::optional< priority_type > priority_optional;
  typedef ::xsd::cxx::tree::traits< priority_type, char > priority_traits;

  const priority_optional&
  priority () const;

  priority_optional&
  priority ();

  void
  priority (const priority_type& x);

  void
  priority (const priority_optional& x);

  // Constructors.
  //
  connection ();

  connection (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  connection (const connection& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual connection*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  connection&
  operator= (const connection& x);

  virtual 
  ~connection ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
  incomingRoad_optional incomingRoad_;
  outgoingRoad_optional outgoingRoad_;
  connectingRoad_optional connectingRoad_;
  contactPoint_optional contactPoint_;
  priority_optional priority_;
};

class laneSection: public ::xml_schema::type
{
  public:
  // leftBoundary
  //
  typedef ::roadBoundary leftBoundary_type;
  typedef ::xsd::cxx::tree::traits< leftBoundary_type, char > leftBoundary_traits;

  const leftBoundary_type&
  leftBoundary () const;

  leftBoundary_type&
  leftBoundary ();

  void
  leftBoundary (const leftBoundary_type& x);

  void
  leftBoundary (::std::unique_ptr< leftBoundary_type > p);

  // rightBoundary
  //
  typedef ::roadBoundary rightBoundary_type;
  typedef ::xsd::cxx::tree::traits< rightBoundary_type, char > rightBoundary_traits;

  const rightBoundary_type&
  rightBoundary () const;

  rightBoundary_type&
  rightBoundary ();

  void
  rightBoundary (const rightBoundary_type& x);

  void
  rightBoundary (::std::unique_ptr< rightBoundary_type > p);

  // left
  //
  typedef ::halfRoad left_type;
  typedef ::xsd::cxx::tree::traits< left_type, char > left_traits;

  const left_type&
  left () const;

  left_type&
  left ();

  void
  left (const left_type& x);

  void
  left (::std::unique_ptr< left_type > p);

  // center
  //
  typedef ::centerRoad center_type;
  typedef ::xsd::cxx::tree::traits< center_type, char > center_traits;

  const center_type&
  center () const;

  center_type&
  center ();

  void
  center (const center_type& x);

  void
  center (::std::unique_ptr< center_type > p);

  // right
  //
  typedef ::halfRoad right_type;
  typedef ::xsd::cxx::tree::traits< right_type, char > right_traits;

  const right_type&
  right () const;

  right_type&
  right ();

  void
  right (const right_type& x);

  void
  right (::std::unique_ptr< right_type > p);

  // singleSide
  //
  typedef ::singleSide singleSide_type;
  typedef ::xsd::cxx::tree::optional< singleSide_type > singleSide_optional;
  typedef ::xsd::cxx::tree::traits< singleSide_type, char > singleSide_traits;

  const singleSide_optional&
  singleSide () const;

  singleSide_optional&
  singleSide ();

  void
  singleSide (const singleSide_type& x);

  void
  singleSide (const singleSide_optional& x);

  void
  singleSide (::std::unique_ptr< singleSide_type > p);

  // Constructors.
  //
  laneSection (const leftBoundary_type&,
               const rightBoundary_type&,
               const left_type&,
               const center_type&,
               const right_type&);

  laneSection (::std::unique_ptr< leftBoundary_type >,
               ::std::unique_ptr< rightBoundary_type >,
               ::std::unique_ptr< left_type >,
               ::std::unique_ptr< center_type >,
               ::std::unique_ptr< right_type >);

  laneSection (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  laneSection (const laneSection& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual laneSection*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  laneSection&
  operator= (const laneSection& x);

  virtual 
  ~laneSection ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< leftBoundary_type > leftBoundary_;
  ::xsd::cxx::tree::one< rightBoundary_type > rightBoundary_;
  ::xsd::cxx::tree::one< left_type > left_;
  ::xsd::cxx::tree::one< center_type > center_;
  ::xsd::cxx::tree::one< right_type > right_;
  singleSide_optional singleSide_;
};

class object: public ::xml_schema::type
{
  public:
  // geometry
  //
  typedef ::geometry geometry_type;
  typedef ::xsd::cxx::tree::traits< geometry_type, char > geometry_traits;

  const geometry_type&
  geometry () const;

  geometry_type&
  geometry ();

  void
  geometry (const geometry_type& x);

  void
  geometry (::std::unique_ptr< geometry_type > p);

  // id
  //
  typedef ::xml_schema::int_ id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  // type
  //
  typedef ::objectType type_type;
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_optional&
  type () const;

  type_optional&
  type ();

  void
  type (const type_type& x);

  void
  type (const type_optional& x);

  void
  type (::std::unique_ptr< type_type > p);

  // Constructors.
  //
  object (const geometry_type&);

  object (::std::unique_ptr< geometry_type >);

  object (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  object (const object& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual object*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  object&
  operator= (const object& x);

  virtual 
  ~object ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< geometry_type > geometry_;
  id_optional id_;
  type_optional type_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& uri,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& uri,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::std::string& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::std::istream& is,
            const ::std::string& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::OpenDRIVE >
OpenDRIVE_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // OPEN_DRIVE_1_4H_HXX
